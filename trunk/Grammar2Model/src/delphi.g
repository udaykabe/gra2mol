/** Delphi 7 grammar
  * Author: Javier Canovas (jlcanovas@um.es)
  * Notes:
  *  This grammar has been extracted from the grammar included in the help section
  *  of Borland Delphi 7 tool
  */

grammar delphi;

options {
	backtrack=true;
	memoize=true;

	output=template;
}


// Autogenerated import
@header {
	import gts.modernization.model.CST.impl.*;
	import gts.modernization.model.CST.*;
	import java.util.Iterator;
}

// Rules
mainRule returns [Node returnNode] 
:	 programGen+=program 
	{
		// Create return CST Node
		Node mainRuleReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mainRuleReturnNode.setKind("mainRule");
	    // Create a CST Node
		if($programGen != null) {
	        for(Iterator it = $programGen.iterator(); it.hasNext(); )  { 
	            delphiParser.program_return r = (delphiParser.program_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("program");
	            	mainRuleReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$mainRule.returnNode = mainRuleReturnNode;
	} 
	| 	 packageDeclGen+=packageDecl 
	{
		// Create return CST Node
		Node mainRuleReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mainRuleReturnNode.setKind("mainRule");
	    // Create a CST Node
		if($packageDeclGen != null) {
	        for(Iterator it = $packageDeclGen.iterator(); it.hasNext(); )  { 
	            delphiParser.packageDecl_return r = (delphiParser.packageDecl_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("packageDecl");
	            	mainRuleReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$mainRule.returnNode = mainRuleReturnNode;
	} 
	| 	 libraryGen+=library 
	{
		// Create return CST Node
		Node mainRuleReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mainRuleReturnNode.setKind("mainRule");
	    // Create a CST Node
		if($libraryGen != null) {
	        for(Iterator it = $libraryGen.iterator(); it.hasNext(); )  { 
	            delphiParser.library_return r = (delphiParser.library_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("library");
	            	mainRuleReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$mainRule.returnNode = mainRuleReturnNode;
	} 
	|	 unitGen+=unit 
	{
		// Create return CST Node
		Node mainRuleReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mainRuleReturnNode.setKind("mainRule");
	    // Create a CST Node
		if($unitGen != null) {
	        for(Iterator it = $unitGen.iterator(); it.hasNext(); )  { 
	            delphiParser.unit_return r = (delphiParser.unit_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("unit");
	            	mainRuleReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$mainRule.returnNode = mainRuleReturnNode;
	}
	;
	
program returns [Node returnNode] 
:	( TK_0='program'  identGen+=ident ( TK_1='('  identListGen+=identList  TK_2=')')?  TK_3=';')?  programBlockGen+=programBlock  TK_4='.' 
	{
		// Create return CST Node
		Node programReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		programReturnNode.setKind("program");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		programReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	programReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		programReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	programReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		programReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		programReturnNode.getChildren().add(TK_3Leaf);
	 	}
	    // Create a CST Node
		if($programBlockGen != null) {
	        for(Iterator it = $programBlockGen.iterator(); it.hasNext(); )  { 
	            delphiParser.programBlock_return r = (delphiParser.programBlock_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("programBlock");
	            	programReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		programReturnNode.getChildren().add(TK_4Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$program.returnNode = programReturnNode;
	}
          ; 
          
unit returns [Node returnNode] 
: 	 TK_0='unit'  identGen+=ident ( portabilityDirectiveGen+=portabilityDirective)?  TK_1=';'  interfaceSectionGen+=interfaceSection  implementationSectionGen+=implementationSection  initSectionGen+=initSection  TK_2='.' 
	{
		// Create return CST Node
		Node unitReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		unitReturnNode.setKind("unit");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		unitReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	unitReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	unitReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		unitReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($interfaceSectionGen != null) {
	        for(Iterator it = $interfaceSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.interfaceSection_return r = (delphiParser.interfaceSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("interfaceSection");
	            	unitReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($implementationSectionGen != null) {
	        for(Iterator it = $implementationSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.implementationSection_return r = (delphiParser.implementationSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("implementationSection");
	            	unitReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($initSectionGen != null) {
	        for(Iterator it = $initSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.initSection_return r = (delphiParser.initSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("initSection");
	            	unitReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		unitReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$unit.returnNode = unitReturnNode;
	}
	;

packageDecl returns [Node returnNode] 
: 	 TK_0='package'  identGen+=ident  TK_1=';' ( requiresClauseGen+=requiresClause)? ( containsClauseGen+=containsClause)?  TK_2='end'  TK_3='.' 
	{
		// Create return CST Node
		Node packageDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		packageDeclReturnNode.setKind("packageDecl");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		packageDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	packageDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		packageDeclReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($requiresClauseGen != null) {
	        for(Iterator it = $requiresClauseGen.iterator(); it.hasNext(); )  { 
	            delphiParser.requiresClause_return r = (delphiParser.requiresClause_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("requiresClause");
	            	packageDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($containsClauseGen != null) {
	        for(Iterator it = $containsClauseGen.iterator(); it.hasNext(); )  { 
	            delphiParser.containsClause_return r = (delphiParser.containsClause_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("containsClause");
	            	packageDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		packageDeclReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		packageDeclReturnNode.getChildren().add(TK_3Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$packageDecl.returnNode = packageDeclReturnNode;
	}
	;

library returns [Node returnNode] 
: 	 TK_0='library'  identGen+=ident  TK_1=';'  programBlockGen+=programBlock  TK_2='.' 
	{
		// Create return CST Node
		Node libraryReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		libraryReturnNode.setKind("library");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		libraryReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	libraryReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		libraryReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($programBlockGen != null) {
	        for(Iterator it = $programBlockGen.iterator(); it.hasNext(); )  { 
	            delphiParser.programBlock_return r = (delphiParser.programBlock_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("programBlock");
	            	libraryReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		libraryReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$library.returnNode = libraryReturnNode;
	}
	;

programBlock returns [Node returnNode] 
: 	( usesClauseGen+=usesClause)?  blockGen+=block 
	{
		// Create return CST Node
		Node programBlockReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		programBlockReturnNode.setKind("programBlock");
	    // Create a CST Node
		if($usesClauseGen != null) {
	        for(Iterator it = $usesClauseGen.iterator(); it.hasNext(); )  { 
	            delphiParser.usesClause_return r = (delphiParser.usesClause_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("usesClause");
	            	programBlockReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($blockGen != null) {
	        for(Iterator it = $blockGen.iterator(); it.hasNext(); )  { 
	            delphiParser.block_return r = (delphiParser.block_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("block");
	            	programBlockReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$programBlock.returnNode = programBlockReturnNode;
	}
	;  

usesClause returns [Node returnNode] 
: 	 TK_0='uses'  identListGen+=identList  TK_1=';' 
	{
		// Create return CST Node
		Node usesClauseReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		usesClauseReturnNode.setKind("usesClause");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		usesClauseReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	usesClauseReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		usesClauseReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$usesClause.returnNode = usesClauseReturnNode;
	}
	;

portabilityDirective returns [Node returnNode] 
: 	 TK_0='platform' 
	{
		// Create return CST Node
		Node portabilityDirectiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		portabilityDirectiveReturnNode.setKind("portabilityDirective");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		portabilityDirectiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$portabilityDirective.returnNode = portabilityDirectiveReturnNode;
	}
    	|	 TK_0='deprecated' 
	{
		// Create return CST Node
		Node portabilityDirectiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		portabilityDirectiveReturnNode.setKind("portabilityDirective");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		portabilityDirectiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$portabilityDirective.returnNode = portabilityDirectiveReturnNode;
	}
    	|	 TK_0='library' 
	{
		// Create return CST Node
		Node portabilityDirectiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		portabilityDirectiveReturnNode.setKind("portabilityDirective");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		portabilityDirectiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$portabilityDirective.returnNode = portabilityDirectiveReturnNode;
	}
	;

interfaceSection returns [Node returnNode] 
: 	 TK_0='interface' ( usesClauseGen+=usesClause)? ( interfaceDeclGen+=interfaceDecl)* 
	{
		// Create return CST Node
		Node interfaceSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		interfaceSectionReturnNode.setKind("interfaceSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		interfaceSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($usesClauseGen != null) {
	        for(Iterator it = $usesClauseGen.iterator(); it.hasNext(); )  { 
	            delphiParser.usesClause_return r = (delphiParser.usesClause_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("usesClause");
	            	interfaceSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($interfaceDeclGen != null) {
	        for(Iterator it = $interfaceDeclGen.iterator(); it.hasNext(); )  { 
	            delphiParser.interfaceDecl_return r = (delphiParser.interfaceDecl_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("interfaceDecl");
	            	interfaceSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$interfaceSection.returnNode = interfaceSectionReturnNode;
	}
	;

interfaceDecl returns [Node returnNode] 
: 	 constSectionGen+=constSection 
	{
		// Create return CST Node
		Node interfaceDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		interfaceDeclReturnNode.setKind("interfaceDecl");
	    // Create a CST Node
		if($constSectionGen != null) {
	        for(Iterator it = $constSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constSection_return r = (delphiParser.constSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constSection");
	            	interfaceDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$interfaceDecl.returnNode = interfaceDeclReturnNode;
	}
    	|	 typeSectionGen+=typeSection 
	{
		// Create return CST Node
		Node interfaceDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		interfaceDeclReturnNode.setKind("interfaceDecl");
	    // Create a CST Node
		if($typeSectionGen != null) {
	        for(Iterator it = $typeSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeSection_return r = (delphiParser.typeSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeSection");
	            	interfaceDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$interfaceDecl.returnNode = interfaceDeclReturnNode;
	}
    	|	 varSectionGen+=varSection 
	{
		// Create return CST Node
		Node interfaceDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		interfaceDeclReturnNode.setKind("interfaceDecl");
	    // Create a CST Node
		if($varSectionGen != null) {
	        for(Iterator it = $varSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.varSection_return r = (delphiParser.varSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("varSection");
	            	interfaceDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$interfaceDecl.returnNode = interfaceDeclReturnNode;
	}
    	|	 exportedHeadingGen+=exportedHeading 
	{
		// Create return CST Node
		Node interfaceDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		interfaceDeclReturnNode.setKind("interfaceDecl");
	    // Create a CST Node
		if($exportedHeadingGen != null) {
	        for(Iterator it = $exportedHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.exportedHeading_return r = (delphiParser.exportedHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("exportedHeading");
	            	interfaceDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$interfaceDecl.returnNode = interfaceDeclReturnNode;
	}
	;

exportedHeading returns [Node returnNode] 
: 	 procedureHeadingGen+=procedureHeading  TK_0=';' ( directiveGen+=directive)? 
	{
		// Create return CST Node
		Node exportedHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		exportedHeadingReturnNode.setKind("exportedHeading");
	    // Create a CST Node
		if($procedureHeadingGen != null) {
	        for(Iterator it = $procedureHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.procedureHeading_return r = (delphiParser.procedureHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("procedureHeading");
	            	exportedHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		exportedHeadingReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($directiveGen != null) {
	        for(Iterator it = $directiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.directive_return r = (delphiParser.directive_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("directive");
	            	exportedHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$exportedHeading.returnNode = exportedHeadingReturnNode;
	}
	| 	 functionHeadingGen+=functionHeading  TK_0=';' ( directiveGen+=directive)? 
	{
		// Create return CST Node
		Node exportedHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		exportedHeadingReturnNode.setKind("exportedHeading");
	    // Create a CST Node
		if($functionHeadingGen != null) {
	        for(Iterator it = $functionHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.functionHeading_return r = (delphiParser.functionHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("functionHeading");
	            	exportedHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		exportedHeadingReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($directiveGen != null) {
	        for(Iterator it = $directiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.directive_return r = (delphiParser.directive_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("directive");
	            	exportedHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$exportedHeading.returnNode = exportedHeadingReturnNode;
	}
	;

implementationSection returns [Node returnNode] 
: 	 TK_0='implementation' ( usesClauseGen+=usesClause)? ( declSectionGen+=declSection)* ( exportsStmtGen+=exportsStmt)* 
	{
		// Create return CST Node
		Node implementationSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		implementationSectionReturnNode.setKind("implementationSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		implementationSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($usesClauseGen != null) {
	        for(Iterator it = $usesClauseGen.iterator(); it.hasNext(); )  { 
	            delphiParser.usesClause_return r = (delphiParser.usesClause_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("usesClause");
	            	implementationSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($declSectionGen != null) {
	        for(Iterator it = $declSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.declSection_return r = (delphiParser.declSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("declSection");
	            	implementationSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($exportsStmtGen != null) {
	        for(Iterator it = $exportsStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.exportsStmt_return r = (delphiParser.exportsStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("exportsStmt");
	            	implementationSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$implementationSection.returnNode = implementationSectionReturnNode;
	}
	;

block returns [Node returnNode] 
: 	( declSectionGen+=declSection)? ( exportsStmtGen+=exportsStmt)*  compoundStmtGen+=compoundStmt ( exportsStmtGen_1+=exportsStmt)* 
	{
		// Create return CST Node
		Node blockReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		blockReturnNode.setKind("block");
	    // Create a CST Node
		if($declSectionGen != null) {
	        for(Iterator it = $declSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.declSection_return r = (delphiParser.declSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("declSection");
	            	blockReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($exportsStmtGen != null) {
	        for(Iterator it = $exportsStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.exportsStmt_return r = (delphiParser.exportsStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("exportsStmt");
	            	blockReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($compoundStmtGen != null) {
	        for(Iterator it = $compoundStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.compoundStmt_return r = (delphiParser.compoundStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("compoundStmt");
	            	blockReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($exportsStmtGen_1 != null) {
	        for(Iterator it = $exportsStmtGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.exportsStmt_return r = (delphiParser.exportsStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("exportsStmt");
	            	blockReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$block.returnNode = blockReturnNode;
	}
	;


exportsItem returns [Node returnNode] 
// modified
	: 	 identGen+=ident ( TK_0='name' |  TK_1='index'   constExprGen+=constExpr)? ( TK_2='index' |  TK_3='name'  constExprGen_1+=constExpr)? 
	{
		// Create return CST Node
		Node exportsItemReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		exportsItemReturnNode.setKind("exportsItem");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	exportsItemReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		exportsItemReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		exportsItemReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	exportsItemReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		exportsItemReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		exportsItemReturnNode.getChildren().add(TK_3Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen_1 != null) {
	        for(Iterator it = $constExprGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	exportsItemReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$exportsItem.returnNode = exportsItemReturnNode;
	}
	;
exportsStmt returns [Node returnNode] 
: 	 TK_0='exports'  exportsItemGen+=exportsItem ( TK_1=','  exportsItemGen_1+=exportsItem)* 
	{
		// Create return CST Node
		Node exportsStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		exportsStmtReturnNode.setKind("exportsStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		exportsStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($exportsItemGen != null) {
	        for(Iterator it = $exportsItemGen.iterator(); it.hasNext(); )  { 
	            delphiParser.exportsItem_return r = (delphiParser.exportsItem_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("exportsItem");
	            	exportsStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal exportsItemGen_1 aggregation
		if($exportsItemGen_1 != null) {
	    for(int pos = 0; pos < $exportsItemGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		exportsStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// No Terminal extractor
	    if($exportsItemGen_1 != null) {		
	    	delphiParser.exportsItem_return r = (delphiParser.exportsItem_return) $exportsItemGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("exportsItem");
	    		exportsStmtReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$exportsStmt.returnNode = exportsStmtReturnNode;
	}
	;


declSection returns [Node returnNode] 
: 	 labelDeclSectionGen+=labelDeclSection 
	{
		// Create return CST Node
		Node declSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		declSectionReturnNode.setKind("declSection");
	    // Create a CST Node
		if($labelDeclSectionGen != null) {
	        for(Iterator it = $labelDeclSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.labelDeclSection_return r = (delphiParser.labelDeclSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("labelDeclSection");
	            	declSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$declSection.returnNode = declSectionReturnNode;
	}
    	|	 constSectionGen+=constSection 
	{
		// Create return CST Node
		Node declSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		declSectionReturnNode.setKind("declSection");
	    // Create a CST Node
		if($constSectionGen != null) {
	        for(Iterator it = $constSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constSection_return r = (delphiParser.constSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constSection");
	            	declSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$declSection.returnNode = declSectionReturnNode;
	}
    	| 	 typeSectionGen+=typeSection 
	{
		// Create return CST Node
		Node declSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		declSectionReturnNode.setKind("declSection");
	    // Create a CST Node
		if($typeSectionGen != null) {
	        for(Iterator it = $typeSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeSection_return r = (delphiParser.typeSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeSection");
	            	declSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$declSection.returnNode = declSectionReturnNode;
	}
    	| 	 varSectionGen+=varSection 
	{
		// Create return CST Node
		Node declSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		declSectionReturnNode.setKind("declSection");
	    // Create a CST Node
		if($varSectionGen != null) {
	        for(Iterator it = $varSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.varSection_return r = (delphiParser.varSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("varSection");
	            	declSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$declSection.returnNode = declSectionReturnNode;
	}
    	| 	 procedureDeclSectionGen+=procedureDeclSection 
	{
		// Create return CST Node
		Node declSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		declSectionReturnNode.setKind("declSection");
	    // Create a CST Node
		if($procedureDeclSectionGen != null) {
	        for(Iterator it = $procedureDeclSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.procedureDeclSection_return r = (delphiParser.procedureDeclSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("procedureDeclSection");
	            	declSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$declSection.returnNode = declSectionReturnNode;
	}
	;

labelDeclSection returns [Node returnNode] 
: 	 TK_0='label'  labelIdGen+=labelId 
	{
		// Create return CST Node
		Node labelDeclSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		labelDeclSectionReturnNode.setKind("labelDeclSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		labelDeclSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($labelIdGen != null) {
	        for(Iterator it = $labelIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.labelId_return r = (delphiParser.labelId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("labelId");
	            	labelDeclSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$labelDeclSection.returnNode = labelDeclSectionReturnNode;
	}
	;

constSection returns [Node returnNode] 
: 	 TK_0='const' ( constantDeclGen+=constantDecl  TK_1=';')* 
	{
		// Create return CST Node
		Node constSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		constSectionReturnNode.setKind("constSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		constSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}

		// Create a special CST Node for terminal constantDeclGen aggregation
		if($constantDeclGen != null) {
	    for(int pos = 0; pos < $constantDeclGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($constantDeclGen != null) {		
	    	delphiParser.constantDecl_return r = (delphiParser.constantDecl_return) $constantDeclGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("constantDecl");
	    		constSectionReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		constSectionReturnNode.getChildren().add(TK_1Leaf);
	 	}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$constSection.returnNode = constSectionReturnNode;
	}
	;

constantDecl returns [Node returnNode] 
: 	 identGen+=ident  TK_0='='  constExprGen+=constExpr ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node constantDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		constantDeclReturnNode.setKind("constantDecl");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	constantDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		constantDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	constantDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	constantDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$constantDecl.returnNode = constantDeclReturnNode;
	}
    	|	 identGen+=ident  TK_0=':'  typeIdGen+=typeId  TK_1='='  typedConstantGen+=typedConstant ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node constantDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		constantDeclReturnNode.setKind("constantDecl");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	constantDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		constantDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	constantDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		constantDeclReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($typedConstantGen != null) {
	        for(Iterator it = $typedConstantGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typedConstant_return r = (delphiParser.typedConstant_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typedConstant");
	            	constantDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	constantDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$constantDecl.returnNode = constantDeclReturnNode;
	}
	;

typeSection returns [Node returnNode] 
:	 TK_0='type' ( typeDeclGen+=typeDecl  TK_1=';')* 
	{
		// Create return CST Node
		Node typeSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeSectionReturnNode.setKind("typeSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		typeSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}

		// Create a special CST Node for terminal typeDeclGen aggregation
		if($typeDeclGen != null) {
	    for(int pos = 0; pos < $typeDeclGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($typeDeclGen != null) {		
	    	delphiParser.typeDecl_return r = (delphiParser.typeDecl_return) $typeDeclGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("typeDecl");
	    		typeSectionReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		typeSectionReturnNode.getChildren().add(TK_1Leaf);
	 	}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$typeSection.returnNode = typeSectionReturnNode;
	}
	;

typeDecl returns [Node returnNode] 
: 	 identGen+=ident  TK_0='=' ( TK_1='type')?  typeGen+=type ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node typeDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeDeclReturnNode.setKind("typeDecl");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	typeDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		typeDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		typeDeclReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($typeGen != null) {
	        for(Iterator it = $typeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.type_return r = (delphiParser.type_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("type");
	            	typeDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	typeDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$typeDecl.returnNode = typeDeclReturnNode;
	}
	|	 identGen+=ident  TK_0='=' ( TK_1='type')?  restrictedTypeGen+=restrictedType ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node typeDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeDeclReturnNode.setKind("typeDecl");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	typeDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		typeDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		typeDeclReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($restrictedTypeGen != null) {
	        for(Iterator it = $restrictedTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.restrictedType_return r = (delphiParser.restrictedType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("restrictedType");
	            	typeDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	typeDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$typeDecl.returnNode = typeDeclReturnNode;
	}
	;

typedConstant returns [Node returnNode] 
: 	( constExprGen+=constExpr |  arrayConstantGen+=arrayConstant |  recordConstantGen+=recordConstant)? 
	{
		// Create return CST Node
		Node typedConstantReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typedConstantReturnNode.setKind("typedConstant");
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	typedConstantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($arrayConstantGen != null) {
	        for(Iterator it = $arrayConstantGen.iterator(); it.hasNext(); )  { 
	            delphiParser.arrayConstant_return r = (delphiParser.arrayConstant_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("arrayConstant");
	            	typedConstantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($recordConstantGen != null) {
	        for(Iterator it = $recordConstantGen.iterator(); it.hasNext(); )  { 
	            delphiParser.recordConstant_return r = (delphiParser.recordConstant_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("recordConstant");
	            	typedConstantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$typedConstant.returnNode = typedConstantReturnNode;
	}
	;

arrayConstant returns [Node returnNode] 
: 	 TK_0='('  typedConstantGen+=typedConstant  TK_1=','  TK_2=')' 
	{
		// Create return CST Node
		Node arrayConstantReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		arrayConstantReturnNode.setKind("arrayConstant");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		arrayConstantReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($typedConstantGen != null) {
	        for(Iterator it = $typedConstantGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typedConstant_return r = (delphiParser.typedConstant_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typedConstant");
	            	arrayConstantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		arrayConstantReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		arrayConstantReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$arrayConstant.returnNode = arrayConstantReturnNode;
	}
	;

recordConstant returns [Node returnNode] 
: 	 TK_0='(' ( recordFieldConstantGen+=recordFieldConstant  TK_1=';')*  TK_2=')' 
	{
		// Create return CST Node
		Node recordConstantReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		recordConstantReturnNode.setKind("recordConstant");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		recordConstantReturnNode.getChildren().add(TK_0Leaf);
	 	}

		// Create a special CST Node for terminal recordFieldConstantGen aggregation
		if($recordFieldConstantGen != null) {
	    for(int pos = 0; pos < $recordFieldConstantGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($recordFieldConstantGen != null) {		
	    	delphiParser.recordFieldConstant_return r = (delphiParser.recordFieldConstant_return) $recordFieldConstantGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("recordFieldConstant");
	    		recordConstantReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		recordConstantReturnNode.getChildren().add(TK_1Leaf);
	 	}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		recordConstantReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$recordConstant.returnNode = recordConstantReturnNode;
	} 
	;

recordFieldConstant returns [Node returnNode] 
: 	 identGen+=ident  TK_0=':'  typedConstantGen+=typedConstant 
	{
		// Create return CST Node
		Node recordFieldConstantReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		recordFieldConstantReturnNode.setKind("recordFieldConstant");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	recordFieldConstantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		recordFieldConstantReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($typedConstantGen != null) {
	        for(Iterator it = $typedConstantGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typedConstant_return r = (delphiParser.typedConstant_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typedConstant");
	            	recordFieldConstantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$recordFieldConstant.returnNode = recordFieldConstantReturnNode;
	}
	;

type returns [Node returnNode] 
: 	 typeIdGen+=typeId 
	{
		// Create return CST Node
		Node typeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeReturnNode.setKind("type");
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	typeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$type.returnNode = typeReturnNode;
	}
    	|	 simpleTypeGen+=simpleType 
	{
		// Create return CST Node
		Node typeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeReturnNode.setKind("type");
	    // Create a CST Node
		if($simpleTypeGen != null) {
	        for(Iterator it = $simpleTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.simpleType_return r = (delphiParser.simpleType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("simpleType");
	            	typeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$type.returnNode = typeReturnNode;
	}
   	|	 strucTypeGen+=strucType 
	{
		// Create return CST Node
		Node typeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeReturnNode.setKind("type");
	    // Create a CST Node
		if($strucTypeGen != null) {
	        for(Iterator it = $strucTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.strucType_return r = (delphiParser.strucType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("strucType");
	            	typeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$type.returnNode = typeReturnNode;
	}
    	|	 pointerTypeGen+=pointerType 
	{
		// Create return CST Node
		Node typeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeReturnNode.setKind("type");
	    // Create a CST Node
		if($pointerTypeGen != null) {
	        for(Iterator it = $pointerTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.pointerType_return r = (delphiParser.pointerType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("pointerType");
	            	typeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$type.returnNode = typeReturnNode;
	}
    	|	 stringTypeGen+=stringType 
	{
		// Create return CST Node
		Node typeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeReturnNode.setKind("type");
	    // Create a CST Node
		if($stringTypeGen != null) {
	        for(Iterator it = $stringTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.stringType_return r = (delphiParser.stringType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stringType");
	            	typeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$type.returnNode = typeReturnNode;
	} 
    	|	 procedureTypeGen+=procedureType 
	{
		// Create return CST Node
		Node typeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeReturnNode.setKind("type");
	    // Create a CST Node
		if($procedureTypeGen != null) {
	        for(Iterator it = $procedureTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.procedureType_return r = (delphiParser.procedureType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("procedureType");
	            	typeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$type.returnNode = typeReturnNode;
	}
   	|	 variantTypeGen+=variantType 
	{
		// Create return CST Node
		Node typeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeReturnNode.setKind("type");
	    // Create a CST Node
		if($variantTypeGen != null) {
	        for(Iterator it = $variantTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.variantType_return r = (delphiParser.variantType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("variantType");
	            	typeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$type.returnNode = typeReturnNode;
	}
    	|	 classRefTypeGen+=classRefType 
	{
		// Create return CST Node
		Node typeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeReturnNode.setKind("type");
	    // Create a CST Node
		if($classRefTypeGen != null) {
	        for(Iterator it = $classRefTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classRefType_return r = (delphiParser.classRefType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classRefType");
	            	typeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$type.returnNode = typeReturnNode;
	}
	;

restrictedType returns [Node returnNode] 
: 	 objectTypeGen+=objectType 
	{
		// Create return CST Node
		Node restrictedTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		restrictedTypeReturnNode.setKind("restrictedType");
	    // Create a CST Node
		if($objectTypeGen != null) {
	        for(Iterator it = $objectTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.objectType_return r = (delphiParser.objectType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("objectType");
	            	restrictedTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$restrictedType.returnNode = restrictedTypeReturnNode;
	}
    	|	 classTypeGen+=classType 
	{
		// Create return CST Node
		Node restrictedTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		restrictedTypeReturnNode.setKind("restrictedType");
	    // Create a CST Node
		if($classTypeGen != null) {
	        for(Iterator it = $classTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classType_return r = (delphiParser.classType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classType");
	            	restrictedTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$restrictedType.returnNode = restrictedTypeReturnNode;
	}
    	|	 interfaceTypeGen+=interfaceType 
	{
		// Create return CST Node
		Node restrictedTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		restrictedTypeReturnNode.setKind("restrictedType");
	    // Create a CST Node
		if($interfaceTypeGen != null) {
	        for(Iterator it = $interfaceTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.interfaceType_return r = (delphiParser.interfaceType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("interfaceType");
	            	restrictedTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$restrictedType.returnNode = restrictedTypeReturnNode;
	}
	;

classRefType returns [Node returnNode] 
: 	 TK_0='class'  TK_1='of'  typeIdGen+=typeId 
	{
		// Create return CST Node
		Node classRefTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classRefTypeReturnNode.setKind("classRefType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		classRefTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		classRefTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	classRefTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$classRefType.returnNode = classRefTypeReturnNode;
	}
	;

simpleType returns [Node returnNode] 
: 	 ordinalTypeGen+=ordinalType 
	{
		// Create return CST Node
		Node simpleTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		simpleTypeReturnNode.setKind("simpleType");
	    // Create a CST Node
		if($ordinalTypeGen != null) {
	        for(Iterator it = $ordinalTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ordinalType_return r = (delphiParser.ordinalType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ordinalType");
	            	simpleTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$simpleType.returnNode = simpleTypeReturnNode;
	} 
	| 	 realTypeGen+=realType 
	{
		// Create return CST Node
		Node simpleTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		simpleTypeReturnNode.setKind("simpleType");
	    // Create a CST Node
		if($realTypeGen != null) {
	        for(Iterator it = $realTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.realType_return r = (delphiParser.realType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("realType");
	            	simpleTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$simpleType.returnNode = simpleTypeReturnNode;
	}
	;

realType returns [Node returnNode] 
: 	 TK_0='real48' 
	{
		// Create return CST Node
		Node realTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		realTypeReturnNode.setKind("realType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		realTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$realType.returnNode = realTypeReturnNode;
	}
    	|	 TK_0='real' 
	{
		// Create return CST Node
		Node realTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		realTypeReturnNode.setKind("realType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		realTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$realType.returnNode = realTypeReturnNode;
	}
    	|	 TK_0='single' 
	{
		// Create return CST Node
		Node realTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		realTypeReturnNode.setKind("realType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		realTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$realType.returnNode = realTypeReturnNode;
	}
    	|	 TK_0='double' 
	{
		// Create return CST Node
		Node realTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		realTypeReturnNode.setKind("realType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		realTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$realType.returnNode = realTypeReturnNode;
	}
    	|	 TK_0='extended' 
	{
		// Create return CST Node
		Node realTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		realTypeReturnNode.setKind("realType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		realTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$realType.returnNode = realTypeReturnNode;
	}
    	|	 TK_0='currency' 
	{
		// Create return CST Node
		Node realTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		realTypeReturnNode.setKind("realType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		realTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$realType.returnNode = realTypeReturnNode;
	}
    	|	 TK_0='comp' 
	{
		// Create return CST Node
		Node realTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		realTypeReturnNode.setKind("realType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		realTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$realType.returnNode = realTypeReturnNode;
	}
	;

ordinalType returns [Node returnNode] 
: 	 subrangeTypeGen+=subrangeType 
	{
		// Create return CST Node
		Node ordinalTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordinalTypeReturnNode.setKind("ordinalType");
	    // Create a CST Node
		if($subrangeTypeGen != null) {
	        for(Iterator it = $subrangeTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.subrangeType_return r = (delphiParser.subrangeType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("subrangeType");
	            	ordinalTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$ordinalType.returnNode = ordinalTypeReturnNode;
	} 
	| 	 enumeratedTypeGen+=enumeratedType 
	{
		// Create return CST Node
		Node ordinalTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordinalTypeReturnNode.setKind("ordinalType");
	    // Create a CST Node
		if($enumeratedTypeGen != null) {
	        for(Iterator it = $enumeratedTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.enumeratedType_return r = (delphiParser.enumeratedType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("enumeratedType");
	            	ordinalTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$ordinalType.returnNode = ordinalTypeReturnNode;
	} 
	| 	 ordIdentGen+=ordIdent 
	{
		// Create return CST Node
		Node ordinalTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordinalTypeReturnNode.setKind("ordinalType");
	    // Create a CST Node
		if($ordIdentGen != null) {
	        for(Iterator it = $ordIdentGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ordIdent_return r = (delphiParser.ordIdent_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ordIdent");
	            	ordinalTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$ordinalType.returnNode = ordinalTypeReturnNode;
	}
	;

ordIdent returns [Node returnNode] 
: 	 TK_0='shortint' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='smallint' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='integer' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='byte' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
	| 	 TK_0='longint' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
   	|	 TK_0='int64' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='word' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='boolean' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='char' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='widechar' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='longword' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
    	|	 TK_0='pchar' 
	{
		// Create return CST Node
		Node ordIdentReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ordIdentReturnNode.setKind("ordIdent");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ordIdentReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ordIdent.returnNode = ordIdentReturnNode;
	}
	;

variantType returns [Node returnNode] 
: 	 TK_0='variant' 
	{
		// Create return CST Node
		Node variantTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		variantTypeReturnNode.setKind("variantType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		variantTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$variantType.returnNode = variantTypeReturnNode;
	}
    	|	 TK_0='olevariant' 
	{
		// Create return CST Node
		Node variantTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		variantTypeReturnNode.setKind("variantType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		variantTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$variantType.returnNode = variantTypeReturnNode;
	}
	;

subrangeType returns [Node returnNode] 
: 	 constExprGen+=constExpr  TK_0='..'  constExprGen_1+=constExpr 
	{
		// Create return CST Node
		Node subrangeTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		subrangeTypeReturnNode.setKind("subrangeType");
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	subrangeTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		subrangeTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen_1 != null) {
	        for(Iterator it = $constExprGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	subrangeTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$subrangeType.returnNode = subrangeTypeReturnNode;
	}
	;

enumeratedType returns [Node returnNode] 
: 	 TK_0='(' ( enumeratedTypeElementGen+=enumeratedTypeElement  TK_1=',')*  TK_2=')' 
	{
		// Create return CST Node
		Node enumeratedTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		enumeratedTypeReturnNode.setKind("enumeratedType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		enumeratedTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}

		// Create a special CST Node for terminal enumeratedTypeElementGen aggregation
		if($enumeratedTypeElementGen != null) {
	    for(int pos = 0; pos < $enumeratedTypeElementGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($enumeratedTypeElementGen != null) {		
	    	delphiParser.enumeratedTypeElement_return r = (delphiParser.enumeratedTypeElement_return) $enumeratedTypeElementGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("enumeratedTypeElement");
	    		enumeratedTypeReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		enumeratedTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		enumeratedTypeReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$enumeratedType.returnNode = enumeratedTypeReturnNode;
	}
	;

enumeratedTypeElement returns [Node returnNode] 
: 	 identGen+=ident ( TK_0='='  constExprGen+=constExpr )? 
	{
		// Create return CST Node
		Node enumeratedTypeElementReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		enumeratedTypeElementReturnNode.setKind("enumeratedTypeElement");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	enumeratedTypeElementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		enumeratedTypeElementReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	enumeratedTypeElementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$enumeratedTypeElement.returnNode = enumeratedTypeElementReturnNode;
	}
	;

stringType returns [Node returnNode] 
: 	 TK_0='string' 
	{
		// Create return CST Node
		Node stringTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		stringTypeReturnNode.setKind("stringType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		stringTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$stringType.returnNode = stringTypeReturnNode;
	}
    	|	 TK_0='ansistring' 
	{
		// Create return CST Node
		Node stringTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		stringTypeReturnNode.setKind("stringType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		stringTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$stringType.returnNode = stringTypeReturnNode;
	}
    	|	 TK_0='widestring' 
	{
		// Create return CST Node
		Node stringTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		stringTypeReturnNode.setKind("stringType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		stringTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$stringType.returnNode = stringTypeReturnNode;
	}
    	|	 TK_0='string'  TK_1='('  constExprGen+=constExpr  TK_2=')' 
	{
		// Create return CST Node
		Node stringTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		stringTypeReturnNode.setKind("stringType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		stringTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		stringTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	stringTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		stringTypeReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$stringType.returnNode = stringTypeReturnNode;
	}
	;

strucType returns [Node returnNode] 
: 	( TK_0='packed')? ( arrayTypeGen+=arrayType |  setTypeGen+=setType |  fileTypeGen+=fileType |  recTypeGen+=recType ( TK_1='packed')?) 
	{
		// Create return CST Node
		Node strucTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		strucTypeReturnNode.setKind("strucType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		strucTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($arrayTypeGen != null) {
	        for(Iterator it = $arrayTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.arrayType_return r = (delphiParser.arrayType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("arrayType");
	            	strucTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($setTypeGen != null) {
	        for(Iterator it = $setTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.setType_return r = (delphiParser.setType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("setType");
	            	strucTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($fileTypeGen != null) {
	        for(Iterator it = $fileTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.fileType_return r = (delphiParser.fileType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("fileType");
	            	strucTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($recTypeGen != null) {
	        for(Iterator it = $recTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.recType_return r = (delphiParser.recType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("recType");
	            	strucTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		strucTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$strucType.returnNode = strucTypeReturnNode;
	}
	;

arrayType returns [Node returnNode] 
: 	 TK_0='array' ( TK_1='['  ordinalTypeGen+=ordinalType ( TK_2=','  ordinalTypeGen_1+=ordinalType)*  TK_3=']')?  TK_4='of'  typeGen+=type ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node arrayTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		arrayTypeReturnNode.setKind("arrayType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		arrayTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		arrayTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($ordinalTypeGen != null) {
	        for(Iterator it = $ordinalTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ordinalType_return r = (delphiParser.ordinalType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ordinalType");
	            	arrayTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal ordinalTypeGen_1 aggregation
		if($ordinalTypeGen_1 != null) {
	    for(int pos = 0; pos < $ordinalTypeGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		arrayTypeReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// No Terminal extractor
	    if($ordinalTypeGen_1 != null) {		
	    	delphiParser.ordinalType_return r = (delphiParser.ordinalType_return) $ordinalTypeGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("ordinalType");
	    		arrayTypeReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		arrayTypeReturnNode.getChildren().add(TK_3Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		arrayTypeReturnNode.getChildren().add(TK_4Leaf);
	 	}
	    // Create a CST Node
		if($typeGen != null) {
	        for(Iterator it = $typeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.type_return r = (delphiParser.type_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("type");
	            	arrayTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	arrayTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$arrayType.returnNode = arrayTypeReturnNode;
	}
	;

recType returns [Node returnNode] 
: 	 TK_0='record' ( fieldListGen+=fieldList)?  TK_1='end' ( portabilityDirectiveGen+=portabilityDirective) ? 
	{
		// Create return CST Node
		Node recTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		recTypeReturnNode.setKind("recType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		recTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($fieldListGen != null) {
	        for(Iterator it = $fieldListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.fieldList_return r = (delphiParser.fieldList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("fieldList");
	            	recTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		recTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	recTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$recType.returnNode = recTypeReturnNode;
	}
	;

fieldList returns [Node returnNode] 
: 	( fieldDeclGen+=fieldDecl  TK_0=';')+ ( variantSectionGen+=variantSection)? ( TK_1=';')? 
	{
		// Create return CST Node
		Node fieldListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		fieldListReturnNode.setKind("fieldList");

		// Create a special CST Node for terminal fieldDeclGen aggregation
		if($fieldDeclGen != null) {
	    for(int pos = 0; pos < $fieldDeclGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($fieldDeclGen != null) {		
	    	delphiParser.fieldDecl_return r = (delphiParser.fieldDecl_return) $fieldDeclGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("fieldDecl");
	    		fieldListReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		fieldListReturnNode.getChildren().add(TK_0Leaf);
	 	}
		}
		}

	    // Create a CST Node
		if($variantSectionGen != null) {
	        for(Iterator it = $variantSectionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.variantSection_return r = (delphiParser.variantSection_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("variantSection");
	            	fieldListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		fieldListReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$fieldList.returnNode = fieldListReturnNode;
	}
	;

fieldDecl returns [Node returnNode] 
: 	 identListGen+=identList  TK_0=':'  typeGen+=type ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node fieldDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		fieldDeclReturnNode.setKind("fieldDecl");
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	fieldDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		fieldDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($typeGen != null) {
	        for(Iterator it = $typeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.type_return r = (delphiParser.type_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("type");
	            	fieldDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	fieldDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$fieldDecl.returnNode = fieldDeclReturnNode;
	}
	;

variantSection returns [Node returnNode] 
: 	 TK_0='case' ( identGen+=ident  TK_1=':')?  typeIdGen+=typeId  TK_2='of' ( recVariantGen+=recVariant  TK_3=';')+ 
	{
		// Create return CST Node
		Node variantSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		variantSectionReturnNode.setKind("variantSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		variantSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	variantSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		variantSectionReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	variantSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		variantSectionReturnNode.getChildren().add(TK_2Leaf);
	 	}

		// Create a special CST Node for terminal recVariantGen aggregation
		if($recVariantGen != null) {
	    for(int pos = 0; pos < $recVariantGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($recVariantGen != null) {		
	    	delphiParser.recVariant_return r = (delphiParser.recVariant_return) $recVariantGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("recVariant");
	    		variantSectionReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		variantSectionReturnNode.getChildren().add(TK_3Leaf);
	 	}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$variantSection.returnNode = variantSectionReturnNode;
	}
	;

recVariant returns [Node returnNode] 
: 	 constExprGen+=constExpr  TK_0=',' ( constExprGen_1+=constExpr)+  TK_1=':'  TK_2='(' ( fieldListGen+=fieldList)  TK_3=')' 
	{
		// Create return CST Node
		Node recVariantReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		recVariantReturnNode.setKind("recVariant");
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	recVariantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		recVariantReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen_1 != null) {
	        for(Iterator it = $constExprGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	recVariantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		recVariantReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		recVariantReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a CST Node
		if($fieldListGen != null) {
	        for(Iterator it = $fieldListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.fieldList_return r = (delphiParser.fieldList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("fieldList");
	            	recVariantReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		recVariantReturnNode.getChildren().add(TK_3Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$recVariant.returnNode = recVariantReturnNode;
	}
	;

setType returns [Node returnNode] 
: 	 TK_0='set'  TK_1='of'  ordinalTypeGen+=ordinalType ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node setTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		setTypeReturnNode.setKind("setType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		setTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		setTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($ordinalTypeGen != null) {
	        for(Iterator it = $ordinalTypeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ordinalType_return r = (delphiParser.ordinalType_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ordinalType");
	            	setTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	setTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$setType.returnNode = setTypeReturnNode;
	}
	;

fileType returns [Node returnNode] 
: 	 TK_0='file'  TK_1='of'  typeIdGen+=typeId ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node fileTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		fileTypeReturnNode.setKind("fileType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		fileTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		fileTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	fileTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	fileTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$fileType.returnNode = fileTypeReturnNode;
	}
	;

pointerType returns [Node returnNode] 
: 	 TK_0='^'  typeIdGen+=typeId ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node pointerTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		pointerTypeReturnNode.setKind("pointerType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		pointerTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	pointerTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	pointerTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$pointerType.returnNode = pointerTypeReturnNode;
	}
	;

procedureType returns [Node returnNode] 
: 	( procedureHeadingGen+=procedureHeading |  functionHeadingGen+=functionHeading) ( TK_0='of'  TK_1='object')? 
	{
		// Create return CST Node
		Node procedureTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		procedureTypeReturnNode.setKind("procedureType");
	    // Create a CST Node
		if($procedureHeadingGen != null) {
	        for(Iterator it = $procedureHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.procedureHeading_return r = (delphiParser.procedureHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("procedureHeading");
	            	procedureTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($functionHeadingGen != null) {
	        for(Iterator it = $functionHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.functionHeading_return r = (delphiParser.functionHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("functionHeading");
	            	procedureTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		procedureTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		procedureTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$procedureType.returnNode = procedureTypeReturnNode;
	}
	;

varSection returns [Node returnNode] 
: 	 TK_0='var' ( varDeclGen+=varDecl  TK_1=';')+ 
	{
		// Create return CST Node
		Node varSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		varSectionReturnNode.setKind("varSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		varSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}

		// Create a special CST Node for terminal varDeclGen aggregation
		if($varDeclGen != null) {
	    for(int pos = 0; pos < $varDeclGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($varDeclGen != null) {		
	    	delphiParser.varDecl_return r = (delphiParser.varDecl_return) $varDeclGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("varDecl");
	    		varSectionReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		varSectionReturnNode.getChildren().add(TK_1Leaf);
	 	}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$varSection.returnNode = varSectionReturnNode;
	}
	;

varDecl returns [Node returnNode] 
: 	 identListGen+=identList  TK_0=':'  typeGen+=type (( TK_1='absolute' ( identGen+=ident |  constExprGen+=constExpr)) |  TK_2='='  constExprGen_1+=constExpr)? ( portabilityDirectiveGen+=portabilityDirective)? 
	{
		// Create return CST Node
		Node varDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		varDeclReturnNode.setKind("varDecl");
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	varDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		varDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($typeGen != null) {
	        for(Iterator it = $typeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.type_return r = (delphiParser.type_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("type");
	            	varDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		varDeclReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	varDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	varDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		varDeclReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen_1 != null) {
	        for(Iterator it = $constExprGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	varDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	varDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$varDecl.returnNode = varDeclReturnNode;
	}
//	| 	identList ':' type ('absolute' (ident) | '=' constExpr)? (portabilityDirective)?
	;

expression returns [Node returnNode] 
: 	 simpleExpressionGen+=simpleExpression ( relOpGen+=relOp  simpleExpressionGen_1+=simpleExpression)* 
	{
		// Create return CST Node
		Node expressionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		expressionReturnNode.setKind("expression");
	    // Create a CST Node
		if($simpleExpressionGen != null) {
	        for(Iterator it = $simpleExpressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.simpleExpression_return r = (delphiParser.simpleExpression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("simpleExpression");
	            	expressionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal relOpGen aggregation
		if($relOpGen != null) {
	    for(int pos = 0; pos < $relOpGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($relOpGen != null) {		
	    	delphiParser.relOp_return r = (delphiParser.relOp_return) $relOpGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("relOp");
	    		expressionReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		// No Terminal extractor
	    if($simpleExpressionGen_1 != null) {		
	    	delphiParser.simpleExpression_return r = (delphiParser.simpleExpression_return) $simpleExpressionGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("simpleExpression");
	    		expressionReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$expression.returnNode = expressionReturnNode;
	}
	;

simpleExpression returns [Node returnNode] 
: 	( TK_0='+' |  TK_1='-')?  termGen+=term ( addOpGen+=addOp  termGen_1+=term)* 
	{
		// Create return CST Node
		Node simpleExpressionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		simpleExpressionReturnNode.setKind("simpleExpression");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		simpleExpressionReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		simpleExpressionReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($termGen != null) {
	        for(Iterator it = $termGen.iterator(); it.hasNext(); )  { 
	            delphiParser.term_return r = (delphiParser.term_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("term");
	            	simpleExpressionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal addOpGen aggregation
		if($addOpGen != null) {
	    for(int pos = 0; pos < $addOpGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($addOpGen != null) {		
	    	delphiParser.addOp_return r = (delphiParser.addOp_return) $addOpGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("addOp");
	    		simpleExpressionReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		// No Terminal extractor
	    if($termGen_1 != null) {		
	    	delphiParser.term_return r = (delphiParser.term_return) $termGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("term");
	    		simpleExpressionReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$simpleExpression.returnNode = simpleExpressionReturnNode;
	}	
	;

term returns [Node returnNode] 
: 	 factorGen+=factor ( mulOpGen+=mulOp  factorGen_1+=factor)* 
	{
		// Create return CST Node
		Node termReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		termReturnNode.setKind("term");
	    // Create a CST Node
		if($factorGen != null) {
	        for(Iterator it = $factorGen.iterator(); it.hasNext(); )  { 
	            delphiParser.factor_return r = (delphiParser.factor_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("factor");
	            	termReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal mulOpGen aggregation
		if($mulOpGen != null) {
	    for(int pos = 0; pos < $mulOpGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($mulOpGen != null) {		
	    	delphiParser.mulOp_return r = (delphiParser.mulOp_return) $mulOpGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("mulOp");
	    		termReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		// No Terminal extractor
	    if($factorGen_1 != null) {		
	    	delphiParser.factor_return r = (delphiParser.factor_return) $factorGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("factor");
	    		termReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$term.returnNode = termReturnNode;
	}
	;

factor returns [Node returnNode] 
: 	 designatorGen+=designator ( TK_0='('  exprListGen+=exprList  TK_1=')')? 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a CST Node
		if($designatorGen != null) {
	        for(Iterator it = $designatorGen.iterator(); it.hasNext(); )  { 
	            delphiParser.designator_return r = (delphiParser.designator_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("designator");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		factorReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($exprListGen != null) {
	        for(Iterator it = $exprListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.exprList_return r = (delphiParser.exprList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("exprList");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		factorReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
   	|	 TK_0='@'  designatorGen+=designator 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		factorReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($designatorGen != null) {
	        for(Iterator it = $designatorGen.iterator(); it.hasNext(); )  { 
	            delphiParser.designator_return r = (delphiParser.designator_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("designator");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
    	|	 numberGen+=number 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a CST Node
		if($numberGen != null) {
	        for(Iterator it = $numberGen.iterator(); it.hasNext(); )  { 
	            delphiParser.number_return r = (delphiParser.number_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("number");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
    	|	 stringGen+=string 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a CST Node
		if($stringGen != null) {
	        for(Iterator it = $stringGen.iterator(); it.hasNext(); )  { 
	            delphiParser.string_return r = (delphiParser.string_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("string");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
    	|	 TK_0='nil' 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		factorReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
    	|	 TK_0='('  expressionGen+=expression  TK_1=')' 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		factorReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		factorReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
    	|	 TK_0='not'  factorGen+=factor 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		factorReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($factorGen != null) {
	        for(Iterator it = $factorGen.iterator(); it.hasNext(); )  { 
	            delphiParser.factor_return r = (delphiParser.factor_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("factor");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
    	|	 setConstructorGen+=setConstructor 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a CST Node
		if($setConstructorGen != null) {
	        for(Iterator it = $setConstructorGen.iterator(); it.hasNext(); )  { 
	            delphiParser.setConstructor_return r = (delphiParser.setConstructor_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("setConstructor");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
    	|	 typeIdGen+=typeId  TK_0='('  expressionGen+=expression  TK_1=')' 
	{
		// Create return CST Node
		Node factorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		factorReturnNode.setKind("factor");
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		factorReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	factorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		factorReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$factor.returnNode = factorReturnNode;
	}
	;

relOp returns [Node returnNode] 
: 	 TK_0='=' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
	|	 TK_0='>' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
    	|	 TK_0='<' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
    	|	 TK_0='<=' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
    	|	 TK_0='>=' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
    	|	 TK_0='<>' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
	|	 TK_0='in' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
    	|	 TK_0='is' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
    	|	 TK_0='as' 
	{
		// Create return CST Node
		Node relOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		relOpReturnNode.setKind("relOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		relOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$relOp.returnNode = relOpReturnNode;
	}
	;

addOp returns [Node returnNode] 
: 	 TK_0='+' 
	{
		// Create return CST Node
		Node addOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		addOpReturnNode.setKind("addOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		addOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$addOp.returnNode = addOpReturnNode;
	}
    	|	 TK_0='-' 
	{
		// Create return CST Node
		Node addOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		addOpReturnNode.setKind("addOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		addOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$addOp.returnNode = addOpReturnNode;
	}
    	|	 TK_0='or' 
	{
		// Create return CST Node
		Node addOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		addOpReturnNode.setKind("addOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		addOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$addOp.returnNode = addOpReturnNode;
	}
    	|	 TK_0='xor' 
	{
		// Create return CST Node
		Node addOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		addOpReturnNode.setKind("addOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		addOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$addOp.returnNode = addOpReturnNode;
	}
	;

mulOp returns [Node returnNode] 
: 	 TK_0='*' 
	{
		// Create return CST Node
		Node mulOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mulOpReturnNode.setKind("mulOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		mulOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$mulOp.returnNode = mulOpReturnNode;
	}
   	|	 TK_0='/' 
	{
		// Create return CST Node
		Node mulOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mulOpReturnNode.setKind("mulOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		mulOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$mulOp.returnNode = mulOpReturnNode;
	}
    	|	 TK_0='div' 
	{
		// Create return CST Node
		Node mulOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mulOpReturnNode.setKind("mulOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		mulOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$mulOp.returnNode = mulOpReturnNode;
	}
    	|	 TK_0='mod' 
	{
		// Create return CST Node
		Node mulOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mulOpReturnNode.setKind("mulOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		mulOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$mulOp.returnNode = mulOpReturnNode;
	}
    	|	 TK_0='and' 
	{
		// Create return CST Node
		Node mulOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mulOpReturnNode.setKind("mulOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		mulOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$mulOp.returnNode = mulOpReturnNode;
	}
    	|	 TK_0='shl' 
	{
		// Create return CST Node
		Node mulOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mulOpReturnNode.setKind("mulOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		mulOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$mulOp.returnNode = mulOpReturnNode;
	}
    	|	 TK_0='shr' 
	{
		// Create return CST Node
		Node mulOpReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		mulOpReturnNode.setKind("mulOp");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		mulOpReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$mulOp.returnNode = mulOpReturnNode;
	}
	;

designator returns [Node returnNode] 
: 	 qualIdGen+=qualId ( TK_0='.'  identGen+=ident |  TK_1='['  exprListGen+=exprList  TK_2=']' |  TK_3='^')* 
	{
		// Create return CST Node
		Node designatorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		designatorReturnNode.setKind("designator");
	    // Create a CST Node
		if($qualIdGen != null) {
	        for(Iterator it = $qualIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.qualId_return r = (delphiParser.qualId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("qualId");
	            	designatorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal identGen aggregation
		if($identGen != null) {
	    for(int pos = 0; pos < $identGen.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		designatorReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// No Terminal extractor
	    if($identGen != null) {		
	    	delphiParser.ident_return r = (delphiParser.ident_return) $identGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("ident");
	    		designatorReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}


		// Create a special CST Node for terminal exprListGen aggregation
		if($exprListGen != null) {
	    for(int pos = 0; pos < $exprListGen.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		designatorReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// No Terminal extractor
	    if($exprListGen != null) {		
	    	delphiParser.exprList_return r = (delphiParser.exprList_return) $exprListGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("exprList");
	    		designatorReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		designatorReturnNode.getChildren().add(TK_2Leaf);
	 	}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		designatorReturnNode.getChildren().add(TK_3Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$designator.returnNode = designatorReturnNode;
	}
	;

setConstructor returns [Node returnNode] 
: 	 TK_0='[' ( setElementGen+=setElement ( TK_1=','  setElementGen_1+=setElement)*)  TK_2=']' 
	{
		// Create return CST Node
		Node setConstructorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		setConstructorReturnNode.setKind("setConstructor");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		setConstructorReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($setElementGen != null) {
	        for(Iterator it = $setElementGen.iterator(); it.hasNext(); )  { 
	            delphiParser.setElement_return r = (delphiParser.setElement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("setElement");
	            	setConstructorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal setElementGen_1 aggregation
		if($setElementGen_1 != null) {
	    for(int pos = 0; pos < $setElementGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		setConstructorReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// No Terminal extractor
	    if($setElementGen_1 != null) {		
	    	delphiParser.setElement_return r = (delphiParser.setElement_return) $setElementGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("setElement");
	    		setConstructorReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		setConstructorReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$setConstructor.returnNode = setConstructorReturnNode;
	}
	;

setElement returns [Node returnNode] 
: 	 expressionGen+=expression ( TK_0='..'  expressionGen_1+=expression)? 
	{
		// Create return CST Node
		Node setElementReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		setElementReturnNode.setKind("setElement");
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	setElementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		setElementReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen_1 != null) {
	        for(Iterator it = $expressionGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	setElementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$setElement.returnNode = setElementReturnNode;
	}
	;

exprList returns [Node returnNode] 
: 	 expressionGen+=expression ( TK_0=','  expressionGen_1+=expression)* 
	{
		// Create return CST Node
		Node exprListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		exprListReturnNode.setKind("exprList");
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	exprListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal expressionGen_1 aggregation
		if($expressionGen_1 != null) {
	    for(int pos = 0; pos < $expressionGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		exprListReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// No Terminal extractor
	    if($expressionGen_1 != null) {		
	    	delphiParser.expression_return r = (delphiParser.expression_return) $expressionGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("expression");
	    		exprListReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$exprList.returnNode = exprListReturnNode;
	}
	;

statement returns [Node returnNode] 
: 	( labelIdGen+=labelId  TK_0=':')? ( simpleStatementGen+=simpleStatement |  structStmtGen+=structStmt) 
	{
		// Create return CST Node
		Node statementReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		statementReturnNode.setKind("statement");
	    // Create a CST Node
		if($labelIdGen != null) {
	        for(Iterator it = $labelIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.labelId_return r = (delphiParser.labelId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("labelId");
	            	statementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		statementReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($simpleStatementGen != null) {
	        for(Iterator it = $simpleStatementGen.iterator(); it.hasNext(); )  { 
	            delphiParser.simpleStatement_return r = (delphiParser.simpleStatement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("simpleStatement");
	            	statementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($structStmtGen != null) {
	        for(Iterator it = $structStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.structStmt_return r = (delphiParser.structStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("structStmt");
	            	statementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$statement.returnNode = statementReturnNode;
	} 
	;

stmtList returns [Node returnNode] 
: 	( statementGen+=statement ( TK_0=';')?)* 
	{
		// Create return CST Node
		Node stmtListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		stmtListReturnNode.setKind("stmtList");

		// Create a special CST Node for terminal statementGen aggregation
		if($statementGen != null) {
	    for(int pos = 0; pos < $statementGen.size(); pos++ )  { 
		// No Terminal extractor
	    if($statementGen != null) {		
	    	delphiParser.statement_return r = (delphiParser.statement_return) $statementGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("statement");
	    		stmtListReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		stmtListReturnNode.getChildren().add(TK_0Leaf);
	 	}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$stmtList.returnNode = stmtListReturnNode;
	}
	;
	
simpleStatement returns [Node returnNode] 
:	 designatorGen+=designator  TK_0=':='  expressionGen+=expression 
	{
		// Create return CST Node
		Node simpleStatementReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		simpleStatementReturnNode.setKind("simpleStatement");
	    // Create a CST Node
		if($designatorGen != null) {
	        for(Iterator it = $designatorGen.iterator(); it.hasNext(); )  { 
	            delphiParser.designator_return r = (delphiParser.designator_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("designator");
	            	simpleStatementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		simpleStatementReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	simpleStatementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$simpleStatement.returnNode = simpleStatementReturnNode;
	} 	
	|	 designatorGen+=designator ( TK_0='(' ( exprListGen+=exprList)  TK_1=')')? 
	{
		// Create return CST Node
		Node simpleStatementReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		simpleStatementReturnNode.setKind("simpleStatement");
	    // Create a CST Node
		if($designatorGen != null) {
	        for(Iterator it = $designatorGen.iterator(); it.hasNext(); )  { 
	            delphiParser.designator_return r = (delphiParser.designator_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("designator");
	            	simpleStatementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		simpleStatementReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($exprListGen != null) {
	        for(Iterator it = $exprListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.exprList_return r = (delphiParser.exprList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("exprList");
	            	simpleStatementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		simpleStatementReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$simpleStatement.returnNode = simpleStatementReturnNode;
	}
	| 	 TK_0='inherited' 
	{
		// Create return CST Node
		Node simpleStatementReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		simpleStatementReturnNode.setKind("simpleStatement");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		simpleStatementReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$simpleStatement.returnNode = simpleStatementReturnNode;
	}
    	|	 TK_0='goto'  labelIdGen+=labelId 
	{
		// Create return CST Node
		Node simpleStatementReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		simpleStatementReturnNode.setKind("simpleStatement");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		simpleStatementReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($labelIdGen != null) {
	        for(Iterator it = $labelIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.labelId_return r = (delphiParser.labelId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("labelId");
	            	simpleStatementReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$simpleStatement.returnNode = simpleStatementReturnNode;
	}
	;

structStmt returns [Node returnNode] 
: 	 compoundStmtGen+=compoundStmt 
	{
		// Create return CST Node
		Node structStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		structStmtReturnNode.setKind("structStmt");
	    // Create a CST Node
		if($compoundStmtGen != null) {
	        for(Iterator it = $compoundStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.compoundStmt_return r = (delphiParser.compoundStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("compoundStmt");
	            	structStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$structStmt.returnNode = structStmtReturnNode;
	}
    	|	 conditionalStmtGen+=conditionalStmt 
	{
		// Create return CST Node
		Node structStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		structStmtReturnNode.setKind("structStmt");
	    // Create a CST Node
		if($conditionalStmtGen != null) {
	        for(Iterator it = $conditionalStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.conditionalStmt_return r = (delphiParser.conditionalStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("conditionalStmt");
	            	structStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$structStmt.returnNode = structStmtReturnNode;
	}
    	|	 loopStmtGen+=loopStmt 
	{
		// Create return CST Node
		Node structStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		structStmtReturnNode.setKind("structStmt");
	    // Create a CST Node
		if($loopStmtGen != null) {
	        for(Iterator it = $loopStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.loopStmt_return r = (delphiParser.loopStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("loopStmt");
	            	structStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$structStmt.returnNode = structStmtReturnNode;
	}
    	|	 withStmtGen+=withStmt 
	{
		// Create return CST Node
		Node structStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		structStmtReturnNode.setKind("structStmt");
	    // Create a CST Node
		if($withStmtGen != null) {
	        for(Iterator it = $withStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.withStmt_return r = (delphiParser.withStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("withStmt");
	            	structStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$structStmt.returnNode = structStmtReturnNode;
	}
    	|	 tryStmtGen+=tryStmt 
	{
		// Create return CST Node
		Node structStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		structStmtReturnNode.setKind("structStmt");
	    // Create a CST Node
		if($tryStmtGen != null) {
	        for(Iterator it = $tryStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.tryStmt_return r = (delphiParser.tryStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("tryStmt");
	            	structStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$structStmt.returnNode = structStmtReturnNode;
	}
    	|	 raiseStmtGen+=raiseStmt 
	{
		// Create return CST Node
		Node structStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		structStmtReturnNode.setKind("structStmt");
	    // Create a CST Node
		if($raiseStmtGen != null) {
	        for(Iterator it = $raiseStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.raiseStmt_return r = (delphiParser.raiseStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("raiseStmt");
	            	structStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$structStmt.returnNode = structStmtReturnNode;
	}
    	|	 assemblerStmtGen+=assemblerStmt 
	{
		// Create return CST Node
		Node structStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		structStmtReturnNode.setKind("structStmt");
	    // Create a CST Node
		if($assemblerStmtGen != null) {
	        for(Iterator it = $assemblerStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.assemblerStmt_return r = (delphiParser.assemblerStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("assemblerStmt");
	            	structStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$structStmt.returnNode = structStmtReturnNode;
	}
	;

compoundStmt returns [Node returnNode] 
: 	 TK_0='begin'  stmtListGen+=stmtList  TK_1='end' 
	{
		// Create return CST Node
		Node compoundStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		compoundStmtReturnNode.setKind("compoundStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		compoundStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($stmtListGen != null) {
	        for(Iterator it = $stmtListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.stmtList_return r = (delphiParser.stmtList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stmtList");
	            	compoundStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		compoundStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$compoundStmt.returnNode = compoundStmtReturnNode;
	}
	;

conditionalStmt returns [Node returnNode] 
: 	 ifStmtGen+=ifStmt 
	{
		// Create return CST Node
		Node conditionalStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		conditionalStmtReturnNode.setKind("conditionalStmt");
	    // Create a CST Node
		if($ifStmtGen != null) {
	        for(Iterator it = $ifStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ifStmt_return r = (delphiParser.ifStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ifStmt");
	            	conditionalStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$conditionalStmt.returnNode = conditionalStmtReturnNode;
	}
	|	 caseStmtGen+=caseStmt 
	{
		// Create return CST Node
		Node conditionalStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		conditionalStmtReturnNode.setKind("conditionalStmt");
	    // Create a CST Node
		if($caseStmtGen != null) {
	        for(Iterator it = $caseStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.caseStmt_return r = (delphiParser.caseStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("caseStmt");
	            	conditionalStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$conditionalStmt.returnNode = conditionalStmtReturnNode;
	}
	;

ifStmt returns [Node returnNode] 
: 	 TK_0='if'  expressionGen+=expression  TK_1='then'  statementGen+=statement  ( TK_2=';')? ( TK_3='else'  statementGen_1+=statement  ( TK_4=';')?)? 
	{
		// Create return CST Node
		Node ifStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		ifStmtReturnNode.setKind("ifStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		ifStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	ifStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		ifStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($statementGen != null) {
	        for(Iterator it = $statementGen.iterator(); it.hasNext(); )  { 
	            delphiParser.statement_return r = (delphiParser.statement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("statement");
	            	ifStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		ifStmtReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		ifStmtReturnNode.getChildren().add(TK_3Leaf);
	 	}
	    // Create a CST Node
		if($statementGen_1 != null) {
	        for(Iterator it = $statementGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.statement_return r = (delphiParser.statement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("statement");
	            	ifStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		ifStmtReturnNode.getChildren().add(TK_4Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ifStmt.returnNode = ifStmtReturnNode;
	}
	;

caseStmt returns [Node returnNode] 
: 	 TK_0='case'  expressionGen+=expression  TK_1='of'  caseSelectorGen+=caseSelector  TK_2=';' ( caseSelectorGen_1+=caseSelector  TK_3=';')* ( TK_4='else'  stmtListGen+=stmtList) ( TK_5=';')  TK_6='end' 
	{
		// Create return CST Node
		Node caseStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		caseStmtReturnNode.setKind("caseStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		caseStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	caseStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		caseStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($caseSelectorGen != null) {
	        for(Iterator it = $caseSelectorGen.iterator(); it.hasNext(); )  { 
	            delphiParser.caseSelector_return r = (delphiParser.caseSelector_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("caseSelector");
	            	caseStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		caseStmtReturnNode.getChildren().add(TK_2Leaf);
	 	}

		// Create a special CST Node for terminal caseSelectorGen_1 aggregation
		if($caseSelectorGen_1 != null) {
	    for(int pos = 0; pos < $caseSelectorGen_1.size(); pos++ )  { 
		// No Terminal extractor
	    if($caseSelectorGen_1 != null) {		
	    	delphiParser.caseSelector_return r = (delphiParser.caseSelector_return) $caseSelectorGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("caseSelector");
	    		caseStmtReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		caseStmtReturnNode.getChildren().add(TK_3Leaf);
	 	}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		caseStmtReturnNode.getChildren().add(TK_4Leaf);
	 	}
	    // Create a CST Node
		if($stmtListGen != null) {
	        for(Iterator it = $stmtListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.stmtList_return r = (delphiParser.stmtList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stmtList");
	            	caseStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_5 != null) {
			Leaf TK_5Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_5.text, TK_5.getCharPositionInLine(), TK_5.getLine());
	 		caseStmtReturnNode.getChildren().add(TK_5Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_6 != null) {
			Leaf TK_6Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_6.text, TK_6.getCharPositionInLine(), TK_6.getLine());
	 		caseStmtReturnNode.getChildren().add(TK_6Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$caseStmt.returnNode = caseStmtReturnNode;
	}
	;

caseSelector returns [Node returnNode] 
: 	 caseLabelGen+=caseLabel ( TK_0=','  caseLabelGen_1+=caseLabel)*  TK_1=':'  statementGen+=statement  ( TK_2=';')? 
	{
		// Create return CST Node
		Node caseSelectorReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		caseSelectorReturnNode.setKind("caseSelector");
	    // Create a CST Node
		if($caseLabelGen != null) {
	        for(Iterator it = $caseLabelGen.iterator(); it.hasNext(); )  { 
	            delphiParser.caseLabel_return r = (delphiParser.caseLabel_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("caseLabel");
	            	caseSelectorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal caseLabelGen_1 aggregation
		if($caseLabelGen_1 != null) {
	    for(int pos = 0; pos < $caseLabelGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		caseSelectorReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// No Terminal extractor
	    if($caseLabelGen_1 != null) {		
	    	delphiParser.caseLabel_return r = (delphiParser.caseLabel_return) $caseLabelGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("caseLabel");
	    		caseSelectorReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		caseSelectorReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($statementGen != null) {
	        for(Iterator it = $statementGen.iterator(); it.hasNext(); )  { 
	            delphiParser.statement_return r = (delphiParser.statement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("statement");
	            	caseSelectorReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		caseSelectorReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$caseSelector.returnNode = caseSelectorReturnNode;
	}
	;

caseLabel returns [Node returnNode] 
: 	 constExprGen+=constExpr ( TK_0='..'  constExprGen_1+=constExpr)? 
	{
		// Create return CST Node
		Node caseLabelReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		caseLabelReturnNode.setKind("caseLabel");
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	caseLabelReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		caseLabelReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen_1 != null) {
	        for(Iterator it = $constExprGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	caseLabelReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$caseLabel.returnNode = caseLabelReturnNode;
	}
	;

loopStmt returns [Node returnNode] 
: 	 repeatStmtGen+=repeatStmt 
	{
		// Create return CST Node
		Node loopStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		loopStmtReturnNode.setKind("loopStmt");
	    // Create a CST Node
		if($repeatStmtGen != null) {
	        for(Iterator it = $repeatStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.repeatStmt_return r = (delphiParser.repeatStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("repeatStmt");
	            	loopStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$loopStmt.returnNode = loopStmtReturnNode;
	}
	|	 whileStmtGen+=whileStmt 
	{
		// Create return CST Node
		Node loopStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		loopStmtReturnNode.setKind("loopStmt");
	    // Create a CST Node
		if($whileStmtGen != null) {
	        for(Iterator it = $whileStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.whileStmt_return r = (delphiParser.whileStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("whileStmt");
	            	loopStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$loopStmt.returnNode = loopStmtReturnNode;
	}
	|	 forStmtGen+=forStmt 
	{
		// Create return CST Node
		Node loopStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		loopStmtReturnNode.setKind("loopStmt");
	    // Create a CST Node
		if($forStmtGen != null) {
	        for(Iterator it = $forStmtGen.iterator(); it.hasNext(); )  { 
	            delphiParser.forStmt_return r = (delphiParser.forStmt_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("forStmt");
	            	loopStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$loopStmt.returnNode = loopStmtReturnNode;
	}
	;

repeatStmt returns [Node returnNode] 
: 	 TK_0='repeat'  statementGen+=statement  ( TK_1=';')?  TK_2='until'  expressionGen+=expression 
	{
		// Create return CST Node
		Node repeatStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		repeatStmtReturnNode.setKind("repeatStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		repeatStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($statementGen != null) {
	        for(Iterator it = $statementGen.iterator(); it.hasNext(); )  { 
	            delphiParser.statement_return r = (delphiParser.statement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("statement");
	            	repeatStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		repeatStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		repeatStmtReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	repeatStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$repeatStmt.returnNode = repeatStmtReturnNode;
	}
	;

whileStmt returns [Node returnNode] 
: 	 TK_0='while'  expressionGen+=expression  TK_1='do'  statementGen+=statement  ( TK_2=';')? 
	{
		// Create return CST Node
		Node whileStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		whileStmtReturnNode.setKind("whileStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		whileStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	whileStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		whileStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($statementGen != null) {
	        for(Iterator it = $statementGen.iterator(); it.hasNext(); )  { 
	            delphiParser.statement_return r = (delphiParser.statement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("statement");
	            	whileStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		whileStmtReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$whileStmt.returnNode = whileStmtReturnNode;
	}
	;

forStmt returns [Node returnNode] 
: 	 TK_0='for'  qualIdGen+=qualId  TK_1=':='  expressionGen+=expression ( TK_2='to' |  TK_3='downto')  expressionGen_1+=expression  TK_4='do'  statementGen+=statement  ( TK_5=';')? 
	{
		// Create return CST Node
		Node forStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		forStmtReturnNode.setKind("forStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		forStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($qualIdGen != null) {
	        for(Iterator it = $qualIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.qualId_return r = (delphiParser.qualId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("qualId");
	            	forStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		forStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	forStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		forStmtReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		forStmtReturnNode.getChildren().add(TK_3Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen_1 != null) {
	        for(Iterator it = $expressionGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	forStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		forStmtReturnNode.getChildren().add(TK_4Leaf);
	 	}
	    // Create a CST Node
		if($statementGen != null) {
	        for(Iterator it = $statementGen.iterator(); it.hasNext(); )  { 
	            delphiParser.statement_return r = (delphiParser.statement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("statement");
	            	forStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_5 != null) {
			Leaf TK_5Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_5.text, TK_5.getCharPositionInLine(), TK_5.getLine());
	 		forStmtReturnNode.getChildren().add(TK_5Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$forStmt.returnNode = forStmtReturnNode;
	}
	;

withStmt returns [Node returnNode] 
// added simpleStatement
	: 	 TK_0='with'  expressionGen+=expression  TK_1='do'  statementGen+=statement ( TK_2=';')? 
	{
		// Create return CST Node
		Node withStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		withStmtReturnNode.setKind("withStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		withStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	withStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		withStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($statementGen != null) {
	        for(Iterator it = $statementGen.iterator(); it.hasNext(); )  { 
	            delphiParser.statement_return r = (delphiParser.statement_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("statement");
	            	withStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		withStmtReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$withStmt.returnNode = withStmtReturnNode;
	} // changed identList by expression
	;

tryStmt returns [Node returnNode] 
// Joined
	: 	 TK_0='try'  stmtListGen+=stmtList ( TK_1=';')? ( TK_2='except'  exceptionBlockGen+=exceptionBlock |   TK_3='finally'  stmtListGen_1+=stmtList)  TK_4='end' 
	{
		// Create return CST Node
		Node tryStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		tryStmtReturnNode.setKind("tryStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		tryStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($stmtListGen != null) {
	        for(Iterator it = $stmtListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.stmtList_return r = (delphiParser.stmtList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stmtList");
	            	tryStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		tryStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		tryStmtReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a CST Node
		if($exceptionBlockGen != null) {
	        for(Iterator it = $exceptionBlockGen.iterator(); it.hasNext(); )  { 
	            delphiParser.exceptionBlock_return r = (delphiParser.exceptionBlock_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("exceptionBlock");
	            	tryStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		tryStmtReturnNode.getChildren().add(TK_3Leaf);
	 	}
	    // Create a CST Node
		if($stmtListGen_1 != null) {
	        for(Iterator it = $stmtListGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.stmtList_return r = (delphiParser.stmtList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stmtList");
	            	tryStmtReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		tryStmtReturnNode.getChildren().add(TK_4Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$tryStmt.returnNode = tryStmtReturnNode;
	}
	;

exceptionBlock returns [Node returnNode] 
: 	( TK_0='on' ( identGen+=ident  TK_1=':')?  typeGen+=type TK_2='id'  TK_3='do'  statementGen+=statement ( TK_4=';')?)* (( TK_5='else')?  stmtListGen+=stmtList )? 
	{
		// Create return CST Node
		Node exceptionBlockReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		exceptionBlockReturnNode.setKind("exceptionBlock");

		// Create a special CST Node for terminal typeGen aggregation
		if($typeGen != null) {
	    for(int pos = 0; pos < $typeGen.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		exceptionBlockReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// No Terminal extractor
	    if($identGen != null) {		
	    	delphiParser.ident_return r = (delphiParser.ident_return) $identGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("ident");
	    		exceptionBlockReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		exceptionBlockReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// No Terminal extractor
	    if($typeGen != null) {		
	    	delphiParser.type_return r = (delphiParser.type_return) $typeGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("type");
	    		exceptionBlockReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		exceptionBlockReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		exceptionBlockReturnNode.getChildren().add(TK_3Leaf);
	 	}
		// No Terminal extractor
	    if($statementGen != null) {		
	    	delphiParser.statement_return r = (delphiParser.statement_return) $statementGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("statement");
	    		exceptionBlockReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		exceptionBlockReturnNode.getChildren().add(TK_4Leaf);
	 	}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_5 != null) {
			Leaf TK_5Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_5.text, TK_5.getCharPositionInLine(), TK_5.getLine());
	 		exceptionBlockReturnNode.getChildren().add(TK_5Leaf);
	 	}
	    // Create a CST Node
		if($stmtListGen != null) {
	        for(Iterator it = $stmtListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.stmtList_return r = (delphiParser.stmtList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stmtList");
	            	exceptionBlockReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$exceptionBlock.returnNode = exceptionBlockReturnNode;
	}
	;

raiseStmt returns [Node returnNode] 
: 	//'raise' (object)? ('at' address)?
		 TK_0='raise' ( IDGen=ID)? ( TK_1='at'  IDGen_1=ID)? 
	{
		// Create return CST Node
		Node raiseStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		raiseStmtReturnNode.setKind("raiseStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		raiseStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Leaf
		if($IDGen != null) {
			Leaf IDGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", $IDGen.text, IDGen.getCharPositionInLine(), IDGen.getLine());
			raiseStmtReturnNode.getChildren().add(IDGenLeaf);
		}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		raiseStmtReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Leaf
		if($IDGen_1 != null) {
			Leaf IDGen_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", $IDGen_1.text, IDGen_1.getCharPositionInLine(), IDGen_1.getLine());
			raiseStmtReturnNode.getChildren().add(IDGen_1Leaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$raiseStmt.returnNode = raiseStmtReturnNode;
	}
	;

assemblerStmt returns [Node returnNode] 
: 	 TK_0='asm' 
	{
		// Create return CST Node
		Node assemblerStmtReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		assemblerStmtReturnNode.setKind("assemblerStmt");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		assemblerStmtReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$assemblerStmt.returnNode = assemblerStmtReturnNode;
	}
    //|	<assemblylanguage>
    //	|	'end'
	;

procedureDeclSection returns [Node returnNode] 
: 	 procedureDeclGen+=procedureDecl 
	{
		// Create return CST Node
		Node procedureDeclSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		procedureDeclSectionReturnNode.setKind("procedureDeclSection");
	    // Create a CST Node
		if($procedureDeclGen != null) {
	        for(Iterator it = $procedureDeclGen.iterator(); it.hasNext(); )  { 
	            delphiParser.procedureDecl_return r = (delphiParser.procedureDecl_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("procedureDecl");
	            	procedureDeclSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$procedureDeclSection.returnNode = procedureDeclSectionReturnNode;
	}
    	|	 functionDeclGen+=functionDecl 
	{
		// Create return CST Node
		Node procedureDeclSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		procedureDeclSectionReturnNode.setKind("procedureDeclSection");
	    // Create a CST Node
		if($functionDeclGen != null) {
	        for(Iterator it = $functionDeclGen.iterator(); it.hasNext(); )  { 
	            delphiParser.functionDecl_return r = (delphiParser.functionDecl_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("functionDecl");
	            	procedureDeclSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$procedureDeclSection.returnNode = procedureDeclSectionReturnNode;
	}
	;

procedureDecl returns [Node returnNode] 
:	 procedureHeadingGen+=procedureHeading  TK_0=';' ( directiveGen+=directive)? ( portabilityDirectiveGen+=portabilityDirective)?  blockGen+=block  TK_1=';' 
	{
		// Create return CST Node
		Node procedureDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		procedureDeclReturnNode.setKind("procedureDecl");
	    // Create a CST Node
		if($procedureHeadingGen != null) {
	        for(Iterator it = $procedureHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.procedureHeading_return r = (delphiParser.procedureHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("procedureHeading");
	            	procedureDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		procedureDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($directiveGen != null) {
	        for(Iterator it = $directiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.directive_return r = (delphiParser.directive_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("directive");
	            	procedureDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	procedureDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($blockGen != null) {
	        for(Iterator it = $blockGen.iterator(); it.hasNext(); )  { 
	            delphiParser.block_return r = (delphiParser.block_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("block");
	            	procedureDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		procedureDeclReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$procedureDecl.returnNode = procedureDeclReturnNode;
	}
	;

functionDecl returns [Node returnNode] 
: 	 functionHeadingGen+=functionHeading  TK_0=';' ( directiveGen+=directive)? ( portabilityDirectiveGen+=portabilityDirective)?  blockGen+=block  TK_1=';' 
	{
		// Create return CST Node
		Node functionDeclReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		functionDeclReturnNode.setKind("functionDecl");
	    // Create a CST Node
		if($functionHeadingGen != null) {
	        for(Iterator it = $functionHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.functionHeading_return r = (delphiParser.functionHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("functionHeading");
	            	functionDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		functionDeclReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($directiveGen != null) {
	        for(Iterator it = $directiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.directive_return r = (delphiParser.directive_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("directive");
	            	functionDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	functionDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($blockGen != null) {
	        for(Iterator it = $blockGen.iterator(); it.hasNext(); )  { 
	            delphiParser.block_return r = (delphiParser.block_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("block");
	            	functionDeclReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		functionDeclReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$functionDecl.returnNode = functionDeclReturnNode;
	}
	;

functionHeading returns [Node returnNode] 
: 	( TK_0='class')?  TK_1='function'  identGen+=ident ( formalParametersGen+=formalParameters)?  TK_2=':'  typeGen+=type 
	{
		// Create return CST Node
		Node functionHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		functionHeadingReturnNode.setKind("functionHeading");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		functionHeadingReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		functionHeadingReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	functionHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($formalParametersGen != null) {
	        for(Iterator it = $formalParametersGen.iterator(); it.hasNext(); )  { 
	            delphiParser.formalParameters_return r = (delphiParser.formalParameters_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("formalParameters");
	            	functionHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		functionHeadingReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a CST Node
		if($typeGen != null) {
	        for(Iterator it = $typeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.type_return r = (delphiParser.type_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("type");
	            	functionHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$functionHeading.returnNode = functionHeadingReturnNode;
	}
	;

procedureHeading returns [Node returnNode] 
: 	( TK_0='class')? TK_1='procedure'  identGen+=ident ( formalParametersGen+=formalParameters)? 
	{
		// Create return CST Node
		Node procedureHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		procedureHeadingReturnNode.setKind("procedureHeading");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		procedureHeadingReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		procedureHeadingReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	procedureHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($formalParametersGen != null) {
	        for(Iterator it = $formalParametersGen.iterator(); it.hasNext(); )  { 
	            delphiParser.formalParameters_return r = (delphiParser.formalParameters_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("formalParameters");
	            	procedureHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$procedureHeading.returnNode = procedureHeadingReturnNode;
	}
	;

formalParameters returns [Node returnNode] 
: 	 TK_0='(' ( formalParmGen+=formalParm ( TK_1=';'  formalParmGen_1+=formalParm)*)  TK_2=')' 
	{
		// Create return CST Node
		Node formalParametersReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		formalParametersReturnNode.setKind("formalParameters");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		formalParametersReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($formalParmGen != null) {
	        for(Iterator it = $formalParmGen.iterator(); it.hasNext(); )  { 
	            delphiParser.formalParm_return r = (delphiParser.formalParm_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("formalParm");
	            	formalParametersReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal formalParmGen_1 aggregation
		if($formalParmGen_1 != null) {
	    for(int pos = 0; pos < $formalParmGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		formalParametersReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// No Terminal extractor
	    if($formalParmGen_1 != null) {		
	    	delphiParser.formalParm_return r = (delphiParser.formalParm_return) $formalParmGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("formalParm");
	    		formalParametersReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		formalParametersReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$formalParameters.returnNode = formalParametersReturnNode;
	}
	;

formalParm returns [Node returnNode] 
: 	( TK_0='var' |  TK_1='const' |  TK_2='out')?  parameterGen+=parameter 
	{
		// Create return CST Node
		Node formalParmReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		formalParmReturnNode.setKind("formalParm");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		formalParmReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		formalParmReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		formalParmReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a CST Node
		if($parameterGen != null) {
	        for(Iterator it = $parameterGen.iterator(); it.hasNext(); )  { 
	            delphiParser.parameter_return r = (delphiParser.parameter_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("parameter");
	            	formalParmReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$formalParm.returnNode = formalParmReturnNode;
	}
	;

parameter returns [Node returnNode] 
: 	 identListGen+=identList ( TK_0=':' (( TK_1='array'  TK_2='of')?  typeGen+=type |  TK_3='file'))? 
	{
		// Create return CST Node
		Node parameterReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		parameterReturnNode.setKind("parameter");
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	parameterReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		parameterReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		parameterReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		parameterReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a CST Node
		if($typeGen != null) {
	        for(Iterator it = $typeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.type_return r = (delphiParser.type_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("type");
	            	parameterReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		parameterReturnNode.getChildren().add(TK_3Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$parameter.returnNode = parameterReturnNode;
	} // changed simpleType by type, deleted string alternative
	| 	 identGen+=ident  TK_0=':'  typeGen+=type  TK_1='='  constExprGen+=constExpr 
	{
		// Create return CST Node
		Node parameterReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		parameterReturnNode.setKind("parameter");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	parameterReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		parameterReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($typeGen != null) {
	        for(Iterator it = $typeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.type_return r = (delphiParser.type_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("type");
	            	parameterReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		parameterReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	parameterReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$parameter.returnNode = parameterReturnNode;
	} // changed simpleType by type
	;

directive returns [Node returnNode] 
: 	 TK_0='cdecl' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='register' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='dynamic' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='virtual' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='export' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='external' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='near' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='far' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='forward' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
	|	 TK_0='message'  constExprGen+=constExpr 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	directiveReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='override' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='overload' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
   	|	 TK_0='pascal' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
   	|	 TK_0='reintroduce' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='safecall' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='stdcall' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='varargs' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='local' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
    	|	 TK_0='abstract' 
	{
		// Create return CST Node
		Node directiveReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		directiveReturnNode.setKind("directive");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		directiveReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$directive.returnNode = directiveReturnNode;
	}
	;

objectType returns [Node returnNode] 
: 	 TK_0='object' ( objHeritageGen+=objHeritage)? ( objFieldListGen+=objFieldList)? ( methodListGen+=methodList)?  TK_1='end' 
	{
		// Create return CST Node
		Node objectTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		objectTypeReturnNode.setKind("objectType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		objectTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($objHeritageGen != null) {
	        for(Iterator it = $objHeritageGen.iterator(); it.hasNext(); )  { 
	            delphiParser.objHeritage_return r = (delphiParser.objHeritage_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("objHeritage");
	            	objectTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($objFieldListGen != null) {
	        for(Iterator it = $objFieldListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.objFieldList_return r = (delphiParser.objFieldList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("objFieldList");
	            	objectTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($methodListGen != null) {
	        for(Iterator it = $methodListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.methodList_return r = (delphiParser.methodList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("methodList");
	            	objectTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		objectTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$objectType.returnNode = objectTypeReturnNode;
	}
	;

objHeritage returns [Node returnNode] 
: 	 TK_0='('  qualIdGen+=qualId  TK_1=')' 
	{
		// Create return CST Node
		Node objHeritageReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		objHeritageReturnNode.setKind("objHeritage");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		objHeritageReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($qualIdGen != null) {
	        for(Iterator it = $qualIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.qualId_return r = (delphiParser.qualId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("qualId");
	            	objHeritageReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		objHeritageReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$objHeritage.returnNode = objHeritageReturnNode;
	}
	;

methodList returns [Node returnNode] 
: 	( methodHeadingGen+=methodHeading ( TK_0=';'  TK_1='virtual')? ( TK_2=';'  directiveGen+=directive)*)  TK_3=';' 
	{
		// Create return CST Node
		Node methodListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		methodListReturnNode.setKind("methodList");
	    // Create a CST Node
		if($methodHeadingGen != null) {
	        for(Iterator it = $methodHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.methodHeading_return r = (delphiParser.methodHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("methodHeading");
	            	methodListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		methodListReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		methodListReturnNode.getChildren().add(TK_1Leaf);
	 	}

		// Create a special CST Node for terminal directiveGen aggregation
		if($directiveGen != null) {
	    for(int pos = 0; pos < $directiveGen.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		methodListReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// No Terminal extractor
	    if($directiveGen != null) {		
	    	delphiParser.directive_return r = (delphiParser.directive_return) $directiveGen.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("directive");
	    		methodListReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		methodListReturnNode.getChildren().add(TK_3Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$methodList.returnNode = methodListReturnNode;
	}
	;

methodHeading returns [Node returnNode] 
: 	 procedureHeadingGen+=procedureHeading 
	{
		// Create return CST Node
		Node methodHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		methodHeadingReturnNode.setKind("methodHeading");
	    // Create a CST Node
		if($procedureHeadingGen != null) {
	        for(Iterator it = $procedureHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.procedureHeading_return r = (delphiParser.procedureHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("procedureHeading");
	            	methodHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$methodHeading.returnNode = methodHeadingReturnNode;
	}
	|	 functionHeadingGen+=functionHeading 
	{
		// Create return CST Node
		Node methodHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		methodHeadingReturnNode.setKind("methodHeading");
	    // Create a CST Node
		if($functionHeadingGen != null) {
	        for(Iterator it = $functionHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.functionHeading_return r = (delphiParser.functionHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("functionHeading");
	            	methodHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$methodHeading.returnNode = methodHeadingReturnNode;
	}
	|	 constructorHeadingGen+=constructorHeading 
	{
		// Create return CST Node
		Node methodHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		methodHeadingReturnNode.setKind("methodHeading");
	    // Create a CST Node
		if($constructorHeadingGen != null) {
	        for(Iterator it = $constructorHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constructorHeading_return r = (delphiParser.constructorHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constructorHeading");
	            	methodHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$methodHeading.returnNode = methodHeadingReturnNode;
	}
    	|	 destructorHeadingGen+=destructorHeading 
	{
		// Create return CST Node
		Node methodHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		methodHeadingReturnNode.setKind("methodHeading");
	    // Create a CST Node
		if($destructorHeadingGen != null) {
	        for(Iterator it = $destructorHeadingGen.iterator(); it.hasNext(); )  { 
	            delphiParser.destructorHeading_return r = (delphiParser.destructorHeading_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("destructorHeading");
	            	methodHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$methodHeading.returnNode = methodHeadingReturnNode;
	}
	;

constructorHeading returns [Node returnNode] 
: 	 TK_0='constructor'  identGen+=ident ( formalParametersGen+=formalParameters)? 
	{
		// Create return CST Node
		Node constructorHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		constructorHeadingReturnNode.setKind("constructorHeading");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		constructorHeadingReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	constructorHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($formalParametersGen != null) {
	        for(Iterator it = $formalParametersGen.iterator(); it.hasNext(); )  { 
	            delphiParser.formalParameters_return r = (delphiParser.formalParameters_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("formalParameters");
	            	constructorHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$constructorHeading.returnNode = constructorHeadingReturnNode;
	}
	;

destructorHeading returns [Node returnNode] 
: 	 TK_0='destructor'  identGen+=ident ( formalParametersGen+=formalParameters)? 
	{
		// Create return CST Node
		Node destructorHeadingReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		destructorHeadingReturnNode.setKind("destructorHeading");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		destructorHeadingReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	destructorHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($formalParametersGen != null) {
	        for(Iterator it = $formalParametersGen.iterator(); it.hasNext(); )  { 
	            delphiParser.formalParameters_return r = (delphiParser.formalParameters_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("formalParameters");
	            	destructorHeadingReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$destructorHeading.returnNode = destructorHeadingReturnNode;
	}
	;

objFieldList returns [Node returnNode] 
: 	( identListGen+=identList  TK_0=':'  typeGen+=type)  TK_1=';' 
	{
		// Create return CST Node
		Node objFieldListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		objFieldListReturnNode.setKind("objFieldList");
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	objFieldListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		objFieldListReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($typeGen != null) {
	        for(Iterator it = $typeGen.iterator(); it.hasNext(); )  { 
	            delphiParser.type_return r = (delphiParser.type_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("type");
	            	objFieldListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		objFieldListReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$objFieldList.returnNode = objFieldListReturnNode;
	}
	;

initSection returns [Node returnNode] 
: 	 TK_0='initialization'  stmtListGen+=stmtList ( TK_1='finalization'  stmtListGen_1+=stmtList)?  TK_2='end' 
	{
		// Create return CST Node
		Node initSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		initSectionReturnNode.setKind("initSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		initSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($stmtListGen != null) {
	        for(Iterator it = $stmtListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.stmtList_return r = (delphiParser.stmtList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stmtList");
	            	initSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		initSectionReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($stmtListGen_1 != null) {
	        for(Iterator it = $stmtListGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.stmtList_return r = (delphiParser.stmtList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stmtList");
	            	initSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		initSectionReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$initSection.returnNode = initSectionReturnNode;
	}
    	|	 TK_0='begin'  stmtListGen+=stmtList  TK_1='end' 
	{
		// Create return CST Node
		Node initSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		initSectionReturnNode.setKind("initSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		initSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($stmtListGen != null) {
	        for(Iterator it = $stmtListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.stmtList_return r = (delphiParser.stmtList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("stmtList");
	            	initSectionReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		initSectionReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$initSection.returnNode = initSectionReturnNode;
	}
    	|	 TK_0='end' 
	{
		// Create return CST Node
		Node initSectionReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		initSectionReturnNode.setKind("initSection");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		initSectionReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$initSection.returnNode = initSectionReturnNode;
	}
	;

classType returns [Node returnNode] 
: 	 TK_0='class' ( classHeritageGen+=classHeritage)? ( classVisibilityGen+=classVisibility)? ( classFieldListGen+=classFieldList)? ( classMethodListGen+=classMethodList)? ( classPropertyListGen+=classPropertyList)?  TK_1='end' 
	{
		// Create return CST Node
		Node classTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classTypeReturnNode.setKind("classType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		classTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($classHeritageGen != null) {
	        for(Iterator it = $classHeritageGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classHeritage_return r = (delphiParser.classHeritage_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classHeritage");
	            	classTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($classVisibilityGen != null) {
	        for(Iterator it = $classVisibilityGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classVisibility_return r = (delphiParser.classVisibility_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classVisibility");
	            	classTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($classFieldListGen != null) {
	        for(Iterator it = $classFieldListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classFieldList_return r = (delphiParser.classFieldList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classFieldList");
	            	classTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($classMethodListGen != null) {
	        for(Iterator it = $classMethodListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classMethodList_return r = (delphiParser.classMethodList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classMethodList");
	            	classTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($classPropertyListGen != null) {
	        for(Iterator it = $classPropertyListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classPropertyList_return r = (delphiParser.classPropertyList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classPropertyList");
	            	classTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		classTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$classType.returnNode = classTypeReturnNode;
	}
	;

classHeritage returns [Node returnNode] 
: 	 TK_0='('  identListGen+=identList  TK_1=')' 
	{
		// Create return CST Node
		Node classHeritageReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classHeritageReturnNode.setKind("classHeritage");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		classHeritageReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	classHeritageReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		classHeritageReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$classHeritage.returnNode = classHeritageReturnNode;
	}
	;

classVisibility returns [Node returnNode] 
: 	 TK_0='public' 
	{
		// Create return CST Node
		Node classVisibilityReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classVisibilityReturnNode.setKind("classVisibility");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		classVisibilityReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$classVisibility.returnNode = classVisibilityReturnNode;
	} 
	| 	 TK_0='protected' 
	{
		// Create return CST Node
		Node classVisibilityReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classVisibilityReturnNode.setKind("classVisibility");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		classVisibilityReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$classVisibility.returnNode = classVisibilityReturnNode;
	} 
	| 	 TK_0='private' 
	{
		// Create return CST Node
		Node classVisibilityReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classVisibilityReturnNode.setKind("classVisibility");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		classVisibilityReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$classVisibility.returnNode = classVisibilityReturnNode;
	} 
	| 	 TK_0='published' 
	{
		// Create return CST Node
		Node classVisibilityReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classVisibilityReturnNode.setKind("classVisibility");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		classVisibilityReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$classVisibility.returnNode = classVisibilityReturnNode;
	}
	;

classFieldList returns [Node returnNode] 
: 	 classFieldGen+=classField+ 
	{
		// Create return CST Node
		Node classFieldListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classFieldListReturnNode.setKind("classFieldList");
	    // Create a CST Node
		if($classFieldGen != null) {
	        for(Iterator it = $classFieldGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classField_return r = (delphiParser.classField_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classField");
	            	classFieldListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$classFieldList.returnNode = classFieldListReturnNode;
	}
	;

classField returns [Node returnNode] 
:	  classVisibilityGen+=classVisibility?  objFieldListGen+=objFieldList 
	{
		// Create return CST Node
		Node classFieldReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classFieldReturnNode.setKind("classField");
	    // Create a CST Node
		if($classVisibilityGen != null) {
	        for(Iterator it = $classVisibilityGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classVisibility_return r = (delphiParser.classVisibility_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classVisibility");
	            	classFieldReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($objFieldListGen != null) {
	        for(Iterator it = $objFieldListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.objFieldList_return r = (delphiParser.objFieldList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("objFieldList");
	            	classFieldReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$classField.returnNode = classFieldReturnNode;
	}
	;

classMethodList returns [Node returnNode] 
: 	 classMethodGen+=classMethod+ 
	{
		// Create return CST Node
		Node classMethodListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classMethodListReturnNode.setKind("classMethodList");
	    // Create a CST Node
		if($classMethodGen != null) {
	        for(Iterator it = $classMethodGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classMethod_return r = (delphiParser.classMethod_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classMethod");
	            	classMethodListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$classMethodList.returnNode = classMethodListReturnNode;
	}
	;
	
classMethod returns [Node returnNode] 
:	 classVisibilityGen+=classVisibility?  methodListGen+=methodList 
	{
		// Create return CST Node
		Node classMethodReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classMethodReturnNode.setKind("classMethod");
	    // Create a CST Node
		if($classVisibilityGen != null) {
	        for(Iterator it = $classVisibilityGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classVisibility_return r = (delphiParser.classVisibility_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classVisibility");
	            	classMethodReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($methodListGen != null) {
	        for(Iterator it = $methodListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.methodList_return r = (delphiParser.methodList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("methodList");
	            	classMethodReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$classMethod.returnNode = classMethodReturnNode;
	}
	;

classPropertyList returns [Node returnNode] 
: 	 classPropertyGen+=classProperty+ 
	{
		// Create return CST Node
		Node classPropertyListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classPropertyListReturnNode.setKind("classPropertyList");
	    // Create a CST Node
		if($classPropertyGen != null) {
	        for(Iterator it = $classPropertyGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classProperty_return r = (delphiParser.classProperty_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classProperty");
	            	classPropertyListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$classPropertyList.returnNode = classPropertyListReturnNode;
	}
	;
	
classProperty returns [Node returnNode] 
:	 classVisibilityGen+=classVisibility 
	{
		// Create return CST Node
		Node classPropertyReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classPropertyReturnNode.setKind("classProperty");
	    // Create a CST Node
		if($classVisibilityGen != null) {
	        for(Iterator it = $classVisibilityGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classVisibility_return r = (delphiParser.classVisibility_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classVisibility");
	            	classPropertyReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$classProperty.returnNode = classPropertyReturnNode;
	} 
	|	 classVisibilityGen+=classVisibility?  propertyListGen+=propertyList 
	{
		// Create return CST Node
		Node classPropertyReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		classPropertyReturnNode.setKind("classProperty");
	    // Create a CST Node
		if($classVisibilityGen != null) {
	        for(Iterator it = $classVisibilityGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classVisibility_return r = (delphiParser.classVisibility_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classVisibility");
	            	classPropertyReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($propertyListGen != null) {
	        for(Iterator it = $propertyListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.propertyList_return r = (delphiParser.propertyList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("propertyList");
	            	classPropertyReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$classProperty.returnNode = classPropertyReturnNode;
	}
	;
	
propertyList returns [Node returnNode] 
: 	 TK_0='property'  identGen+=ident ( propertyInterfaceGen+=propertyInterface)? ( propertySpecifiersGen+=propertySpecifiers)? ( portabilityDirectiveGen+=portabilityDirective)?  TK_1=';' 
	{
		// Create return CST Node
		Node propertyListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		propertyListReturnNode.setKind("propertyList");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		propertyListReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	propertyListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($propertyInterfaceGen != null) {
	        for(Iterator it = $propertyInterfaceGen.iterator(); it.hasNext(); )  { 
	            delphiParser.propertyInterface_return r = (delphiParser.propertyInterface_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("propertyInterface");
	            	propertyListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($propertySpecifiersGen != null) {
	        for(Iterator it = $propertySpecifiersGen.iterator(); it.hasNext(); )  { 
	            delphiParser.propertySpecifiers_return r = (delphiParser.propertySpecifiers_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("propertySpecifiers");
	            	propertyListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($portabilityDirectiveGen != null) {
	        for(Iterator it = $portabilityDirectiveGen.iterator(); it.hasNext(); )  { 
	            delphiParser.portabilityDirective_return r = (delphiParser.portabilityDirective_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("portabilityDirective");
	            	propertyListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		propertyListReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$propertyList.returnNode = propertyListReturnNode;
	}
	;

propertyInterface returns [Node returnNode] 
: 	( propertyParameterListGen+=propertyParameterList)?  TK_0=':'  identGen+=ident 
	{
		// Create return CST Node
		Node propertyInterfaceReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		propertyInterfaceReturnNode.setKind("propertyInterface");
	    // Create a CST Node
		if($propertyParameterListGen != null) {
	        for(Iterator it = $propertyParameterListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.propertyParameterList_return r = (delphiParser.propertyParameterList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("propertyParameterList");
	            	propertyInterfaceReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		propertyInterfaceReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	propertyInterfaceReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$propertyInterface.returnNode = propertyInterfaceReturnNode;
	}
	;

propertyParameterList returns [Node returnNode] 
: 	 TK_0='['  identListGen+=identList  TK_1=':'  typeIdGen+=typeId  TK_2=';' ( identListGen_1+=identList  TK_3=':'  typeIdGen_1+=typeId  TK_4=';')*  TK_5=']' 
	{
		// Create return CST Node
		Node propertyParameterListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		propertyParameterListReturnNode.setKind("propertyParameterList");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		propertyParameterListReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	propertyParameterListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		propertyParameterListReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	propertyParameterListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		propertyParameterListReturnNode.getChildren().add(TK_2Leaf);
	 	}

		// Create a special CST Node for terminal identListGen_1 aggregation
		if($identListGen_1 != null) {
	    for(int pos = 0; pos < $identListGen_1.size(); pos++ )  { 
		// No Terminal extractor
	    if($identListGen_1 != null) {		
	    	delphiParser.identList_return r = (delphiParser.identList_return) $identListGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("identList");
	    		propertyParameterListReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		propertyParameterListReturnNode.getChildren().add(TK_3Leaf);
	 	}
		// No Terminal extractor
	    if($typeIdGen_1 != null) {		
	    	delphiParser.typeId_return r = (delphiParser.typeId_return) $typeIdGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("typeId");
	    		propertyParameterListReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		propertyParameterListReturnNode.getChildren().add(TK_4Leaf);
	 	}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_5 != null) {
			Leaf TK_5Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_5.text, TK_5.getCharPositionInLine(), TK_5.getLine());
	 		propertyParameterListReturnNode.getChildren().add(TK_5Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$propertyParameterList.returnNode = propertyParameterListReturnNode;
	} 
	;

propertySpecifiers returns [Node returnNode] 
// Modified constExpr
	: 	( TK_0='index'  constExprGen+=constExpr)? ( TK_1='read'  identGen+=ident)? ( TK_2='write'  identGen_1+=ident)? ( TK_3='stored' ( identGen_2+=ident |  constExprGen_1+=constExpr))? (( TK_4='default'  constExprGen_2+=constExpr) |  TK_5='nodefault')? ( TK_6='implements'  typeIdGen+=typeId)? 
	{
		// Create return CST Node
		Node propertySpecifiersReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		propertySpecifiersReturnNode.setKind("propertySpecifiers");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		propertySpecifiersReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	propertySpecifiersReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		propertySpecifiersReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	propertySpecifiersReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		propertySpecifiersReturnNode.getChildren().add(TK_2Leaf);
	 	}
	    // Create a CST Node
		if($identGen_1 != null) {
	        for(Iterator it = $identGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	propertySpecifiersReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_3 != null) {
			Leaf TK_3Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_3.text, TK_3.getCharPositionInLine(), TK_3.getLine());
	 		propertySpecifiersReturnNode.getChildren().add(TK_3Leaf);
	 	}
	    // Create a CST Node
		if($identGen_2 != null) {
	        for(Iterator it = $identGen_2.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	propertySpecifiersReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($constExprGen_1 != null) {
	        for(Iterator it = $constExprGen_1.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	propertySpecifiersReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_4 != null) {
			Leaf TK_4Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_4.text, TK_4.getCharPositionInLine(), TK_4.getLine());
	 		propertySpecifiersReturnNode.getChildren().add(TK_4Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen_2 != null) {
	        for(Iterator it = $constExprGen_2.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	propertySpecifiersReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_5 != null) {
			Leaf TK_5Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_5.text, TK_5.getCharPositionInLine(), TK_5.getLine());
	 		propertySpecifiersReturnNode.getChildren().add(TK_5Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_6 != null) {
			Leaf TK_6Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_6.text, TK_6.getCharPositionInLine(), TK_6.getLine());
	 		propertySpecifiersReturnNode.getChildren().add(TK_6Leaf);
	 	}
	    // Create a CST Node
		if($typeIdGen != null) {
	        for(Iterator it = $typeIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.typeId_return r = (delphiParser.typeId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("typeId");
	            	propertySpecifiersReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$propertySpecifiers.returnNode = propertySpecifiersReturnNode;
	}
	;

interfaceType returns [Node returnNode] 
: 	 TK_0='interface' ( interfaceHeritageGen+=interfaceHeritage) ( classMethodListGen+=classMethodList) ( classPropertyListGen+=classPropertyList)*  TK_1='end' 
	{
		// Create return CST Node
		Node interfaceTypeReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		interfaceTypeReturnNode.setKind("interfaceType");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		interfaceTypeReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($interfaceHeritageGen != null) {
	        for(Iterator it = $interfaceHeritageGen.iterator(); it.hasNext(); )  { 
	            delphiParser.interfaceHeritage_return r = (delphiParser.interfaceHeritage_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("interfaceHeritage");
	            	interfaceTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($classMethodListGen != null) {
	        for(Iterator it = $classMethodListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classMethodList_return r = (delphiParser.classMethodList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classMethodList");
	            	interfaceTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a CST Node
		if($classPropertyListGen != null) {
	        for(Iterator it = $classPropertyListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.classPropertyList_return r = (delphiParser.classPropertyList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("classPropertyList");
	            	interfaceTypeReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		interfaceTypeReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$interfaceType.returnNode = interfaceTypeReturnNode;
	}
	;

interfaceHeritage returns [Node returnNode] 
: 	 TK_0='('  identListGen+=identList  TK_1=')' 
	{
		// Create return CST Node
		Node interfaceHeritageReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		interfaceHeritageReturnNode.setKind("interfaceHeritage");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		interfaceHeritageReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	interfaceHeritageReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		interfaceHeritageReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$interfaceHeritage.returnNode = interfaceHeritageReturnNode;
	}
	;

requiresClause returns [Node returnNode] 
: 	 TK_0='requires'  identListGen+=identList*  TK_1=';' 
	{
		// Create return CST Node
		Node requiresClauseReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		requiresClauseReturnNode.setKind("requiresClause");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		requiresClauseReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	requiresClauseReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		requiresClauseReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$requiresClause.returnNode = requiresClauseReturnNode;
	}
	;

containsClause returns [Node returnNode] 
: 	 TK_0='contains'  identListGen+=identList*  TK_1=';' 
	{
		// Create return CST Node
		Node containsClauseReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		containsClauseReturnNode.setKind("containsClause");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		containsClauseReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identListGen != null) {
	        for(Iterator it = $identListGen.iterator(); it.hasNext(); )  { 
	            delphiParser.identList_return r = (delphiParser.identList_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("identList");
	            	containsClauseReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		containsClauseReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$containsClause.returnNode = containsClauseReturnNode;
	}
	;

identList returns [Node returnNode] 
: 	 identGen+=ident ( TK_0=','  identGen_1+=ident)* 
	{
		// Create return CST Node
		Node identListReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		identListReturnNode.setKind("identList");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	identListReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal identGen_1 aggregation
		if($identGen_1 != null) {
	    for(int pos = 0; pos < $identGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		identListReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// No Terminal extractor
	    if($identGen_1 != null) {		
	    	delphiParser.ident_return r = (delphiParser.ident_return) $identGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("ident");
	    		identListReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$identList.returnNode = identListReturnNode;
	}
	;

qualId returns [Node returnNode] 
: 	( unitIdGen+=unitId  TK_0='.')?  identGen+=ident 
	{
		// Create return CST Node
		Node qualIdReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		qualIdReturnNode.setKind("qualId");
	    // Create a CST Node
		if($unitIdGen != null) {
	        for(Iterator it = $unitIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.unitId_return r = (delphiParser.unitId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("unitId");
	            	qualIdReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		qualIdReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	qualIdReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$qualId.returnNode = qualIdReturnNode;
	}
	;

typeId returns [Node returnNode] 
//modified
	: 	( unitIdGen+=unitId  TK_0='.')?  qualIdGen+=qualId 
	{
		// Create return CST Node
		Node typeIdReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		typeIdReturnNode.setKind("typeId");
	    // Create a CST Node
		if($unitIdGen != null) {
	        for(Iterator it = $unitIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.unitId_return r = (delphiParser.unitId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("unitId");
	            	typeIdReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		typeIdReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($qualIdGen != null) {
	        for(Iterator it = $qualIdGen.iterator(); it.hasNext(); )  { 
	            delphiParser.qualId_return r = (delphiParser.qualId_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("qualId");
	            	typeIdReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$typeId.returnNode = typeIdReturnNode;
	}
	;

ident returns [Node returnNode] 
// modified
	: 	 IDGen=ID ( TK_0='.'  IDGen_1_List+=ID)* 
	{
		// Create return CST Node
		Node identReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		identReturnNode.setKind("ident");
	    // Create a CST Leaf
		if($IDGen != null) {
			Leaf IDGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", $IDGen.text, IDGen.getCharPositionInLine(), IDGen.getLine());
			identReturnNode.getChildren().add(IDGenLeaf);
		}

		// Create a special CST Node for terminal IDGen_1_List aggregation
		if($IDGen_1_List != null) {
	    for(int pos = 0; pos < $IDGen_1_List.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		identReturnNode.getChildren().add(TK_0Leaf);
	 	}
		// Terminal extractor
	    if($IDGen_1_List != null) {
		    Token t = (Token) $IDGen_1_List.get(pos); 
		    Leaf IDGen_1_ListLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", t.getText(), t.getCharPositionInLine(), t.getLine());
			identReturnNode.getChildren().add(IDGen_1_ListLeaf);
		}
		}
		}

		// Returns the Node with CST Leaves/Nodes
		$ident.returnNode = identReturnNode;
	}
	|	 TK_0='&'  reservedWordGen+=reservedWord 
	{
		// Create return CST Node
		Node identReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		identReturnNode.setKind("ident");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		identReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($reservedWordGen != null) {
	        for(Iterator it = $reservedWordGen.iterator(); it.hasNext(); )  { 
	            delphiParser.reservedWord_return r = (delphiParser.reservedWord_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("reservedWord");
	            	identReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$ident.returnNode = identReturnNode;
	}
	|	 IDGen=ID  TK_0='('  IDGen_1=ID  TK_1='^'  TK_2=')' 
	{
		// Create return CST Node
		Node identReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		identReturnNode.setKind("ident");
	    // Create a CST Leaf
		if($IDGen != null) {
			Leaf IDGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", $IDGen.text, IDGen.getCharPositionInLine(), IDGen.getLine());
			identReturnNode.getChildren().add(IDGenLeaf);
		}
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		identReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Leaf
		if($IDGen_1 != null) {
			Leaf IDGen_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", $IDGen_1.text, IDGen_1.getCharPositionInLine(), IDGen_1.getLine());
			identReturnNode.getChildren().add(IDGen_1Leaf);
		}
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		identReturnNode.getChildren().add(TK_1Leaf);
	 	}
	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		identReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$ident.returnNode = identReturnNode;
	} // mine
	;

reservedWord returns [Node returnNode] 
: 	 IDGen=ID 
	{
		// Create return CST Node
		Node reservedWordReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		reservedWordReturnNode.setKind("reservedWord");
	    // Create a CST Leaf
		if($IDGen != null) {
			Leaf IDGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", $IDGen.text, IDGen.getCharPositionInLine(), IDGen.getLine());
			reservedWordReturnNode.getChildren().add(IDGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$reservedWord.returnNode = reservedWordReturnNode;
	}
	;

constExpr returns [Node returnNode] 
// modified
	: 	 expressionGen+=expression 
	{
		// Create return CST Node
		Node constExprReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		constExprReturnNode.setKind("constExpr");
	    // Create a CST Node
		if($expressionGen != null) {
	        for(Iterator it = $expressionGen.iterator(); it.hasNext(); )  { 
	            delphiParser.expression_return r = (delphiParser.expression_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("expression");
	            	constExprReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$constExpr.returnNode = constExprReturnNode;
	}
	|	 TK_0='('  constExprGen+=constExpr ( TK_1=','  constExprGen_1+=constExpr)* TK_2=')' 
	{
		// Create return CST Node
		Node constExprReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		constExprReturnNode.setKind("constExpr");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		constExprReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	constExprReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal constExprGen_1 aggregation
		if($constExprGen_1 != null) {
	    for(int pos = 0; pos < $constExprGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		constExprReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// No Terminal extractor
	    if($constExprGen_1 != null) {		
	    	delphiParser.constExpr_return r = (delphiParser.constExpr_return) $constExprGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("constExpr");
	    		constExprReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		constExprReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$constExpr.returnNode = constExprReturnNode;
	}
	|	 TK_0='('  recordConstExprGen+=recordConstExpr ( TK_1=','  recordConstExprGen_1+=recordConstExpr)*  TK_2=')' 
	{
		// Create return CST Node
		Node constExprReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		constExprReturnNode.setKind("constExpr");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		constExprReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($recordConstExprGen != null) {
	        for(Iterator it = $recordConstExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.recordConstExpr_return r = (delphiParser.recordConstExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("recordConstExpr");
	            	constExprReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }

		// Create a special CST Node for terminal recordConstExprGen_1 aggregation
		if($recordConstExprGen_1 != null) {
	    for(int pos = 0; pos < $recordConstExprGen_1.size(); pos++ )  { 
	    // Create a Token CST Leaf	
	    if($TK_1 != null) {
			Leaf TK_1Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_1.text, TK_1.getCharPositionInLine(), TK_1.getLine());
	 		constExprReturnNode.getChildren().add(TK_1Leaf);
	 	}
		// No Terminal extractor
	    if($recordConstExprGen_1 != null) {		
	    	delphiParser.recordConstExpr_return r = (delphiParser.recordConstExpr_return) $recordConstExprGen_1.get(pos); 
	    	if(r != null && r.returnNode != null) {
	        	r.returnNode.setKind("recordConstExpr");
	    		constExprReturnNode.getChildren().add(r.returnNode);
	    	} 
		}
		}
		}

	    // Create a Token CST Leaf	
	    if($TK_2 != null) {
			Leaf TK_2Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_2.text, TK_2.getCharPositionInLine(), TK_2.getLine());
	 		constExprReturnNode.getChildren().add(TK_2Leaf);
	 	}
		// Returns the Node with CST Leaves/Nodes
		$constExpr.returnNode = constExprReturnNode;
	}
	;

recordConstExpr returns [Node returnNode] 
// added
	:	 identGen+=ident  TK_0=':'  constExprGen+=constExpr 
	{
		// Create return CST Node
		Node recordConstExprReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		recordConstExprReturnNode.setKind("recordConstExpr");
	    // Create a CST Node
		if($identGen != null) {
	        for(Iterator it = $identGen.iterator(); it.hasNext(); )  { 
	            delphiParser.ident_return r = (delphiParser.ident_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("ident");
	            	recordConstExprReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		recordConstExprReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Node
		if($constExprGen != null) {
	        for(Iterator it = $constExprGen.iterator(); it.hasNext(); )  { 
	            delphiParser.constExpr_return r = (delphiParser.constExpr_return) it.next(); 
	            if(r != null && r.returnNode != null) {
	            	r.returnNode.setKind("constExpr");
	            	recordConstExprReturnNode.getChildren().add(r.returnNode);
	            } 
	        }
	    }
		// Returns the Node with CST Leaves/Nodes
		$recordConstExpr.returnNode = recordConstExprReturnNode;
	}
	;

unitId returns [Node returnNode] 
// modified
	: 	 IDGen=ID 
	{
		// Create return CST Node
		Node unitIdReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		unitIdReturnNode.setKind("unitId");
	    // Create a CST Leaf
		if($IDGen != null) {
			Leaf IDGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", $IDGen.text, IDGen.getCharPositionInLine(), IDGen.getLine());
			unitIdReturnNode.getChildren().add(IDGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$unitId.returnNode = unitIdReturnNode;
	}
	;

labelId returns [Node returnNode] 
// modified
	: 	 IDGen=ID 
	{
		// Create return CST Node
		Node labelIdReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		labelIdReturnNode.setKind("labelId");
	    // Create a CST Leaf
		if($IDGen != null) {
			Leaf IDGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("ID", $IDGen.text, IDGen.getCharPositionInLine(), IDGen.getLine());
			labelIdReturnNode.getChildren().add(IDGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$labelId.returnNode = labelIdReturnNode;
	}
	|	 INTGen=INT 
	{
		// Create return CST Node
		Node labelIdReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		labelIdReturnNode.setKind("labelId");
	    // Create a CST Leaf
		if($INTGen != null) {
			Leaf INTGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("INT", $INTGen.text, INTGen.getCharPositionInLine(), INTGen.getLine());
			labelIdReturnNode.getChildren().add(INTGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$labelId.returnNode = labelIdReturnNode;
	}
	|	 HEXGen=HEX 
	{
		// Create return CST Node
		Node labelIdReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		labelIdReturnNode.setKind("labelId");
	    // Create a CST Leaf
		if($HEXGen != null) {
			Leaf HEXGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("HEX", $HEXGen.text, HEXGen.getCharPositionInLine(), HEXGen.getLine());
			labelIdReturnNode.getChildren().add(HEXGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$labelId.returnNode = labelIdReturnNode;
	}
	;

number returns [Node returnNode] 
: 	 INTGen=INT 
	{
		// Create return CST Node
		Node numberReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		numberReturnNode.setKind("number");
	    // Create a CST Leaf
		if($INTGen != null) {
			Leaf INTGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("INT", $INTGen.text, INTGen.getCharPositionInLine(), INTGen.getLine());
			numberReturnNode.getChildren().add(INTGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$number.returnNode = numberReturnNode;
	}
	|	 TK_0='#'  INTGen=INT 
	{
		// Create return CST Node
		Node numberReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		numberReturnNode.setKind("number");
	    // Create a Token CST Leaf	
	    if($TK_0 != null) {
			Leaf TK_0Leaf = CSTFactoryImpl.eINSTANCE.createLeaf("TOKEN", $TK_0.text, TK_0.getCharPositionInLine(), TK_0.getLine());
	 		numberReturnNode.getChildren().add(TK_0Leaf);
	 	}
	    // Create a CST Leaf
		if($INTGen != null) {
			Leaf INTGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("INT", $INTGen.text, INTGen.getCharPositionInLine(), INTGen.getLine());
			numberReturnNode.getChildren().add(INTGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$number.returnNode = numberReturnNode;
	}
	;

string returns [Node returnNode] 
: 	 QVALUEGen=QVALUE 
	{
		// Create return CST Node
		Node stringReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		stringReturnNode.setKind("string");
	    // Create a CST Leaf
		if($QVALUEGen != null) {
			Leaf QVALUEGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("QVALUE", $QVALUEGen.text, QVALUEGen.getCharPositionInLine(), QVALUEGen.getLine());
			stringReturnNode.getChildren().add(QVALUEGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$string.returnNode = stringReturnNode;
	}
	|	 DQVALUEGen=DQVALUE 
	{
		// Create return CST Node
		Node stringReturnNode = CSTFactoryImpl.eINSTANCE.createNode();
		stringReturnNode.setKind("string");
	    // Create a CST Leaf
		if($DQVALUEGen != null) {
			Leaf DQVALUEGenLeaf = CSTFactoryImpl.eINSTANCE.createLeaf("DQVALUE", $DQVALUEGen.text, DQVALUEGen.getCharPositionInLine(), DQVALUEGen.getLine());
			stringReturnNode.getChildren().add(DQVALUEGenLeaf);
		}
		// Returns the Node with CST Leaves/Nodes
		$string.returnNode = stringReturnNode;
	}
	;

// Lexer tokens
SLASH 			:	 '\u005C';
QUOTE			:	 '\u0027';
ID 				:	 ('a'..'z' | 'A'..'Z' | '_') ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '$' | '#' | SLASH | '-')*;
DOUBLEQUOTE		: 	'\u0022';
DQVALUE			: 	DOUBLEQUOTE (options {greedy=false;} : .)* DOUBLEQUOTE;
QVALUE			: 	QUOTE (options {greedy=false;} : .)* QUOTE;
HEX				:	('+' | '-')?  '0' ('x' | 'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+;
INT				: 	('+' | '-')? ('0'..'9')+;
COMMENT			:  	 '/*' ( options {greedy=false;} : . )* '*/' {$channel=HIDDEN;};
MORECOMMENT	:  	 '{' ( options {greedy=false;} : . )* '}' {$channel=HIDDEN;};
LINE_COMMENT		: 	'//' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;} ;
WS  				:  	(' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;};    